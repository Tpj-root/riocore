#!/usr/bin/env python3
#
#

import argparse
import copy
import glob
import hashlib
import importlib
import json
import yaml
import os
import re
import subprocess
import sys
import time
from functools import partial

import graphviz
import riocore
from riocore import halpins
from riocore.plugins import Modifiers
from riocore.widgets import MyQSvgWidget, MyStandardItem, edit_float, edit_int, edit_text, edit_bool, edit_combobox, modifier_selector, STYLESHEET, STYLESHEET_CHECKBOX_GREEN_RED, STYLESHEET_BUTTON


from PyQt5 import QtSvg
from PyQt5.QtCore import QTimer, QPoint, Qt
from PyQt5.QtGui import QStandardItemModel, QFont, QPixmap
from PyQt5.QtWidgets import (
    QMessageBox,
    QHeaderView,
    QSizePolicy,
    QGroupBox,
    QLineEdit,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QListWidget,
    QPlainTextEdit,
    QPushButton,
    QScrollArea,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTreeView,
    QVBoxLayout,
    QWidget,
)

riocore_path = os.path.dirname(riocore.__file__)

# help_text is generated by riocore/files/adoc2helptext.py
help_text = {
    "INI": {
        "EMC": {
            "VERSION": "The version number for the configuration.",
            "MACHINE": "This is the name of the controller, which is printed out at the top of most graphical interfaces.",
            "DEBUG": "Debug level 0 means no messages will be printed when LinuxCNC is run from a <<faq:terminal,terminal>>.",
        },
        "DISPLAY": {
            "DISPLAY": "The file name of the executable providing the user interface to use.",
            "POSITION_OFFSET": "The coordinate system (`RELATIVE` or `MACHINE`) to show on the DRO when the user interface starts.",
            "POSITION_FEEDBACK": "The coordinate value (`COMMANDED` or `ACTUAL`) to show on the DRO when the user interface starts.",
            "DRO_FORMAT_MM": "Override the default DRO formatting in metric mode (normally 3 decimal places, padded with spaces to 6 digits to the left).",
            "DRO_FORMAT_IN": "Override the default DRO formatting in imperial mode (normally 4 decimal places, padded with spaces to 6 digits to the left).",
            "CONE_BASESIZE": "Override the default cone/tool base size of .5 in the graphics display.",
            "MAX_FEED_OVERRIDE": "The maximum feed override the user may select.",
            "MIN_SPINDLE_OVERRIDE": "The minimum spindle override the user may select.",
            "MIN_SPINDLE_0_OVERRIDE": "The minimum spindle override the user may select.",
            "MAX_SPINDLE_OVERRIDE": "The maximum spindle override the user may select. 1.0 means 100% of the programmed spindle speed.",
            "MAX_SPINDLE_0_OVERRIDE": "The maximum feed override the user may select.",
            "DEFAULT_SPINDLE_SPEED": "The default spindle RPM when the spindle is started in manual mode.",
            "DEFAULT_SPINDLE_0_SPEED": "The default spindle RPM when the spindle is started in manual mode.",
            "SPINDLE_INCREMENT": "The increment used when clicking increase/decrease buttons. Only used by the QtVCP based user interfaces.",
            "MIN_SPINDLE_0_SPEED": "The minimum RPM that can be manually selected.",
            "MAX_SPINDLE_0_SPEED": "The maximum RPM that can be manually selected.",
            "PROGRAM_PREFIX": "The default directory for G-code files, named subroutines, and user-defined M-codes.",
            "INTRO_GRAPHIC": "The image shown on the splash screen.",
            "INTRO_TIME": "The maximum time to show the splash screen, in seconds.",
            "CYCLE_TIME": "Cycle time of the display GUI.",
            "PREVIEW_TIMEOUT": "Timeout (in seconds) for loading graphical preview of G-code. Currently AXIS only.",
            "DEFAULT_LINEAR_VELOCITY": "The default velocity for linear jogs, in <<sub:ini:sec:traj,machine units>> per second.",
            "MIN_VELOCITY": "The approximate lowest value the jog slider.",
            "MAX_LINEAR_VELOCITY": "The maximum velocity for linear jogs, in machine units per second.",
            "MIN_LINEAR_VELOCITY": "The approximate lowest value the jog slider.",
            "DEFAULT_ANGULAR_VELOCITY": "The default velocity for angular jogs, in machine units per second.",
            "MIN_ANGULAR_VELOCITY": "The approximate lowest value the angular jog slider.",
            "MAX_ANGULAR_VELOCITY": "The maximum velocity for angular jogs, in machine units per second.",
            "INCREMENTS": "Defines the increments available for incremental jogs.",
            "GRIDS": "Defines the preset values for grid lines.",
            "OPEN_FILE": "The file to show in the preview plot when AXIS starts.",
            "EDITOR": "The editor to use when selecting File > Edit to edit the G-code from the AXIS menu.",
            "TOOL_EDITOR": "The editor to use when editing the tool table",
            "PYVCP": "The PyVCP panel description file.",
            "PYVCP_POSITION": "The placement of the PyVCP panel in the AXIS user interface.",
            "LATHE": 'Any non-empty value (including "0") causes axis to use "lathe mode" with a top view and with Radius and Diameter on the DRO.',
            "BACK_TOOL_LATHE": 'Any non-empty value (including "0") causes axis to use "back tool lathe mode" with inverted X axis.',
            "FOAM": 'Any non-empty value (including "0") causes axis to change the display for foam-cutter mode.',
            "GEOMETRY": "Controls the *preview* and *backplot* of motion.",
            "ARCDIVISION": "Set the quality of preview of arcs.",
            "MDI_HISTORY_FILE": "The name of a local MDI history file.",
            "JOG_AXES": "The order in which jog keys are assigned to axis letters.",
            "JOG_INVERT": "For each axis letter, the jog direction is inverted.",
            "USER_COMMAND_FILE": "The name of an optional, configuration-specific Python file sourced by the AXIS GUI instead of the user-specific file `~/.axisrc`.",
            "HELP_FILE": "Path to help file.",
        },
        "FILTER": {},
        "RS274NGC": {
            "PARAMETER_FILE": "(((PARAMETER FILE)))",
            "ORIENT_OFFSET": "(((ORIENT OFFSET)))",
            "RS274NGC_STARTUP_CODE": "(((RS274NGC STARTUP CODE)))",
            "SUBROUTINE_PATH": "(((SUBROUTINE PATH)))",
            "USER_M_PATH": "(((USER M PATH)))",
        },
        "EMCMOT": {
            "EMCMOT": "the motion controller name is typically used here.",
            "BASE_PERIOD": "the 'Base' task period in nanoseconds.",
            "SERVO_PERIOD": 'This is the "Servo" task period in nanoseconds.',
            "TRAJ_PERIOD": "This is the 'Trajectory Planner' task period in nanoseconds.",
            "COMM_TIMEOUT": "Number of seconds to wait for Motion (the realtime part of the motion controller) to acknowledge receipt of messages from Task (the non-realtime part of the motion controller).",
        },
        "TASK": {},
        "HAL": {
            "HALFILE": "Execute the file 'example.hal' at start up.",
            "TWOPASS": "Use twopass processing for loading HAL components.",
            "HALCMD": "Execute _command_ as a single HAL command.",
            "SHUTDOWN": "Execute the file 'shutdown.hal' when LinuxCNC is exiting.",
            "POSTGUI_HALFILE": "Execute 'example2.hal' after the GUI has created its HAL pins.",
            "HALUI": "adds the HAL user interface pins. +",
        },
        "HALUI": {},
        "APPLICATIONS": {"DELAY": "seconds to wait before starting other applications.", "APP": "Application to be started."},
        "TRAJ": {
            "ARC_BLEND_ENABLE": "Turn on new TP.",
            "ARC_BLEND_FALLBACK_ENABLE": "Optionally fall back to parabolic blends if the estimated speed is faster.",
            "ARC_BLEND_OPTIMIZATION_DEPTH": "Look ahead depth in number of segments.",
            "ARC_BLEND_RAMP_FREQ": "This is a 'cutoff' frequency for using ramped velocity.",
            "SPINDLES": 'The number of spindles to support. It is imperative that this number matches the "num_spindles" parameter passed to the motion module.',
            "COORDINATES": "The names of the axes being controlled.  Only X, Y, Z, A, B, C, U, V, W are valid.",
            "LINEAR_UNITS": "(((LINEAR UNITS))) Specifies the 'machine units' for linear axes.",
            "ANGULAR_UNITS": "(((ANGULAR UNITS))) Specifies the 'machine units' for rotational axes.",
            "DEFAULT_LINEAR_VELOCITY": "The initial rate for jogs of linear axes, in machine units per second.",
            "DEFAULT_LINEAR_ACCELERATION": "In machines with nontrivial kinematics, the acceleration used for \"teleop\" (Cartesian space) jogs, in 'machine units' per second per second.",
            "MAX_LINEAR_VELOCITY": "(((MAX VELOCITY))) The maximum velocity for any axis or coordinated move, in 'machine units' per second.",
            "MAX_LINEAR_ACCELERATION": "(((MAX ACCELERATION))) The maximum acceleration for any axis or coordinated axis move, in 'machine units' per second per second.",
            "POSITION_FILE": "If set to a non-empty value, the joint positions are stored between runs in this file.",
            "NO_FORCE_HOMING": "The default behavior is for LinuxCNC to force the user to home the machine before any MDI command or a program is run.",
            "HOME": "World home position needed for kinematics modules that compute world coordinates using kinematicsForward() when switching from joint to teleop mode.",
            "NO_PROBE_JOG_ERROR": "Allow to bypass probe tripped check when you jog manually.",
            "NO_PROBE_HOME_ERROR": "Allow to bypass probe tripped check when homing is in progress.",
        },
        "KINS": {"JOINTS": "Specifies the number of joints (motors) in the system.", "KINEMATICS": "Specify a kinematics module for the motion module."},
        "AXIS_LETTER": {
            "MAX_VELOCITY": "Maximum velocity for this axis in <<sub:ini:sec:traj,machine units>> per second.",
            "MAX_ACCELERATION": "Maximum acceleration for this axis in machine units per second squared.",
            "MIN_LIMIT": "(((MIN LIMIT))) The minimum limit (soft limit) for axis motion, in machine units.",
            "MAX_LIMIT": "(((MAX LIMIT))) The maximum limit (soft limit) for axis motion, in machine units.",
            "WRAPPED_ROTARY": "When this is set to 1 for an ANGULAR axis the axis will move 0-359.999 degrees.",
            "LOCKING_INDEXER_JOINT": "This value selects a joint to use for a locking indexer for the specified axis _<letter>_.",
            "OFFSET_AV_RATIO": "If nonzero, this item enables the use of HAL input pins for external axis offsets:",
        },
        "JOINT_NUM": {
            "TYPE": "The type of joint, either `LINEAR` or `ANGULAR`.",
            "UNITS": "UNITS",
            "MAX_VELOCITY": "Maximum velocity for this joint in <<sub:ini:sec:traj,machine units>> per second.",
            "MAX_ACCELERATION": "Maximum acceleration for this joint in machine units per second squared.",
            "BACKLASH": "Backlash in machine units.",
            "COMP_FILE": "Compensation file",
            "COMP_FILE_TYPE": "Specifies the type of compensation file.",
            "MIN_LIMIT": "minimum limit",
            "MAX_LIMIT": "maximum  limit",
            "MIN_FERROR": "the maximum allowable following error, in machine units. (slow movements)",
            "FERROR": "the maximum allowable following error, in machine units. (fast movements)",
            "LOCKING_INDEXER": "Indicates the joint is used as a locking indexer.",
            "HOME": "The position that the joint will go to upon completion of the homing sequence.",
            "HOME_SEARCH_VEL": "Initial homing velocity in machine units per second.",
            "HOME_ABSOLUTE_ENCODER": "Used to indicate the joint uses an absolute encoder.",
            "HOME_SEQUENCE": 'Used to define the "Home All" sequence.',
            "HOME_LATCH_VEL": "Specifies the speed and direction that LinuxCNC uses when it makes its final accurate determination of the home switch (if present) and index pulse location (if present)",
            "HOME_FINAL_VEL": "It specifies the speed that LinuxCNC uses when it makes its move from HOME_OFFSET to the HOME position",
            "HOME_USE_INDEX": "Specifies whether or not there is an index pulse",
            "HOME_OFFSET": "Contains the location of the home switch or index pulse, in joint coordinates",
            "HOME_IGNORE_LIMITS": "This flag determines whether LinuxCNC will ignore the limit switch inputs",
            "DEADBAND": "How close is close enough to consider the motor in position, in machine units",
            "BIAS": "This is used by hm2-servo and some others.",
            "P": "The proportional gain for the joint servo.",
            "I": "The integral gain for the joint servo.",
            "D": "The derivative gain for the joint servo.",
            "FF0": "The 0^th^ order feed forward gain.",
            "FF1": "The 1^st^ order feed forward gain.",
            "FF2": "The 2^nd^ order feed forward gain.",
            "MAX_OUTPUT": "The maximum value for the output of the PID compensation that is written to the motor amplifier, in volts.",
            "INPUT_SCALE": "in Sample configs",
            "ENCODER_SCALE": "in PnCconf built configs",
            "SCALE": "in Sample configs",
            "STEP_SCALE": "in PnCconf built configs",
            "STEPGEN_MAXACCEL": " Acceleration limit for the step generator.",
            "STEPGEN_MAXVEL": "Older configuration files have a velocity limit for the step generator as well.",
        },
        "SPINDLE_NUM": {"HOME_SEARCH_VELOCITY": "FIXME: Spindle homing not yet working.", "HOME_SEQUENCE": "FIXME: Spindle homing not yet working"},
        "EMCIO": {
            "EMCIO": "Name of IO controller program.",
            "CYCLE_TIME": "The period, in seconds, at which EMCIO will run.",
            "TOOL_TABLE": "The file which contains tool information, described in the User Manual.",
            "DB_PROGRAM": "Path to an executable program that manages tool data.",
        },
    }
}


mapping = {}


class PinButton(QPushButton):
    def __init__(self, widget, parent=None, pkey=None, bgcolor=None, pin=None):
        super(QPushButton, self).__init__(widget)
        self.parent = parent
        self.pkey = pkey
        self.bgcolor = bgcolor
        self.pin = pin
        if self.parent and self.bgcolor:
            self.setStyleSheet(f"background-color: {self.bgcolor}; font-size:12px;")

    def enterEvent(self, event):
        if self.parent and self.pkey:
            self.parent.pinlayout_mark(self.pkey)

    def leaveEvent(self, event):
        if self.parent and self.pkey:
            self.parent.pinlayout_mark(":")

    def mark(self, color):
        if self.parent and color:
            self.setStyleSheet(f"background-color: {color}; font-size:12px;")

    def unmark(self):
        if self.parent and self.bgcolor:
            self.setStyleSheet(f"background-color: {self.bgcolor}; font-size:12px;")


class ImageMap(QLabel):
    def __init__(self, parent):
        super(QLabel, self).__init__(parent)
        self.parent = parent

    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            print(int(event.pos().x()), int(event.pos().y()))
            configstr = self.setPin(event.pos())
            if configstr:
                slot, name, pin = configstr.split()

                if slot not in mapping:
                    mapping[slot] = {}

                mapping[slot][name] = {"pin": pin, "pos": [int(event.pos().x()) - 5, int(event.pos().y()) - 5], "direction": "output"}
                print(configstr)
                print("")

                slots = []
                for slot, pins in mapping.items():
                    slots.append(
                        {
                            "name": slot,
                            "comment": slot,
                            "default": "",
                            "pins": pins,
                        }
                    )
                print(json.dumps(slots, indent=4))

    def setPin(self, pos):
        dialog = QDialog()
        dialog.setWindowTitle("set pin")
        # dialog.setStyleSheet(STYLESHEET)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        message = QLabel("Slot:")
        dialog.layout.addWidget(message)
        configstr = QLineEdit("JOINT STEP 0")
        dialog.layout.addWidget(configstr)

        dialog.layout.addWidget(dialog_buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return configstr.text()


JOINT_OPTIONS = {
    "scale": {
        "type": float,
    },
    "type": {
        "type": "select",
        "options": ["LINEAR", "ANGULAR"],
    },
    "ferror": {
        "type": float,
    },
    "min_ferror": {
        "type": float,
    },
    "min_limit": {
        "type": float,
    },
    "max_limit": {
        "type": float,
    },
    "max_velocity": {
        "type": float,
    },
    "max_acceleration": {
        "type": float,
    },
    "stepgen_maxaccel": {
        "type": float,
    },
    "home_sequence": {
        "type": int,
    },
    "home": {
        "type": float,
    },
    "home_offset": {
        "type": float,
    },
    "home_search_vel": {
        "type": float,
    },
    "home_latch_vel": {
        "type": float,
    },
    "home_final_vel": {
        "type": float,
    },
    "home_ignore_limits": {
        "type": "select",
        "options": ["YES", "NO"],
    },
    "home_use_index": {
        "type": "select",
        "options": ["YES", "NO"],
    },
}


class WinForm(QWidget):
    def __init__(self, args, parent=None):
        super(WinForm, self).__init__(parent)
        self.setWindowTitle("LinuxCNC-RIO - Setup-GUI")
        # self.setMinimumWidth(1400)
        # self.setMinimumHeight(900)
        self.setStyleSheet(STYLESHEET)

        self.listFile = QListWidget()
        layout = QGridLayout()
        self.setLayout(layout)

        self.treeview = QTreeView()
        # self.treeview.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.model = QStandardItemModel()
        self.model.setHorizontalHeaderLabels(["Name", "Value"])
        self.model.itemChanged.connect(self.itemChanged)
        self.treeview.setModel(self.model)
        self.treeview.setUniformRowHeights(True)

        if not args.config:
            self.config_file = None
            boardcfg = self.select_board()
            if boardcfg:
                self.config = {
                    "name": boardcfg,
                    "boardcfg": boardcfg,
                    "plugins": [],
                }
            elif self.config_file is None:
                exit(1)
        else:
            if os.path.isfile(args.config):
                self.config_file = args.config
            elif os.path.isfile(f"{riocore_path}/configs/{args.config}"):
                self.config_file = f"{riocore_path}/configs/{args.config}"
            else:
                print(f"can not load: {args.config}")
                exit(1)
            print(f"loading: {self.config_file}")

        layout.addWidget(self.treeview, 0, 0)

        self.tabwidget = QTabWidget()
        layout.addWidget(self.tabwidget, 0, 1)
        self.gateware_hash = None
        self.firmware_hash = None

        self.compile_sub = None
        self.compile_start = 0
        self.flash_sub = None
        self.flash_start = 0

        self.pin_table = QTableWidget()
        self.pin_table.setColumnCount(6)
        self.pin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Pin"))
        self.pin_table.setHorizontalHeaderItem(1, QTableWidgetItem("Plugin"))
        self.pin_table.setHorizontalHeaderItem(2, QTableWidgetItem("Pin-Name"))
        self.pin_table.setHorizontalHeaderItem(3, QTableWidgetItem("Mapping"))
        self.pin_table.setHorizontalHeaderItem(4, QTableWidgetItem("Direction"))
        self.pin_table.setHorizontalHeaderItem(5, QTableWidgetItem("Comment"))
        self.pin_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedPins)
        self.pin_table_sort_col = 1

        self.sig_table = QTableWidget()
        self.sig_table.setColumnCount(5)
        self.sig_table.setHorizontalHeaderItem(0, QTableWidgetItem("Halname"))
        self.sig_table.setHorizontalHeaderItem(1, QTableWidgetItem("Dir"))
        self.sig_table.setHorizontalHeaderItem(2, QTableWidgetItem("Target"))
        self.sig_table.setHorizontalHeaderItem(3, QTableWidgetItem("Type"))
        self.sig_table.setHorizontalHeaderItem(4, QTableWidgetItem("Comment"))
        self.sig_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedSignals)
        self.sig_table_sort_col = 1

        self.overview_img = MyQSvgWidget()

        self.img_container = QWidget()
        self.img_layout = QVBoxLayout(self.img_container)
        self.boardimg = QWidget()
        self.img_layout.addWidget(self.boardimg)

        self.pininfo = QLabel("")
        self.pininfo_timer = 0

        ipin_layout = QVBoxLayout()
        ipin_widget = QWidget()
        ipin_widget.setLayout(ipin_layout)
        ipin_layout.addWidget(self.img_container)
        ipin_layout.addWidget(self.pininfo)
        ipin_layout.addStretch()

        self.tabwidget.addTab(ipin_widget, "Board")
        self.tabwidget.addTab(self.overview_img, "Flow")
        self.tabwidget.addTab(self.pin_table, "Pins")
        self.tabwidget.addTab(self.sig_table, "Signals")

        self.jsonpreview = QPlainTextEdit()
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText("...")
        # self.jsonpreview.verticalScrollBar().setValue(0)
        self.tabwidget.addTab(self.jsonpreview, "Json-Preview")

        self.linuxcnc_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.linuxcnc_tabwidget, "LinuxCNC")

        self.gateware_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.gateware_tabwidget, "Gateware")

        self.firmware_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.firmware_tabwidget, "Firmware")

        self.hal_imagew = MyQSvgWidget()

        self.gateware = {
            "rio.v": QPlainTextEdit(),
            "Makefile": QPlainTextEdit(),
            "Compile-Output": QPlainTextEdit(),
            "Flash-Output": QPlainTextEdit(),
        }
        self.firmware = {
            "src/main.ino": QPlainTextEdit(),
            "platformio.ini": QPlainTextEdit(),
        }
        self.linuxcnc = {
            "rio.ini": QPlainTextEdit(),
            "rio.hal": QPlainTextEdit(),
            "custom_postgui.hal": QPlainTextEdit(),
            "rio-gui.xml": QPlainTextEdit(),
            "rio.c": QPlainTextEdit(),
            "rio-hal.svg": self.hal_imagew,
        }

        for filename, widget in self.gateware.items():
            widget.clear()
            widget.insertPlainText("")
            self.gateware_tabwidget.addTab(widget, filename)
        for filename, widget in self.firmware.items():
            widget.clear()
            widget.insertPlainText("")
            self.firmware_tabwidget.addTab(widget, filename)
        for filename, widget in self.linuxcnc.items():
            if filename != "rio-hal.svg":
                widget.clear()
                widget.insertPlainText("")
            self.linuxcnc_tabwidget.addTab(widget, filename)

        container = QWidget()
        button_layout = QHBoxLayout(container)
        layout.addWidget(container, 1, 1)

        self.info_widget = QLabel("loading...")
        layout.addWidget(self.info_widget, 1, 0)

        info_container = QWidget()
        info_layout = QHBoxLayout(info_container)
        layout.addWidget(info_container, 2, 1)

        self.info_saved = QCheckBox("Saved")
        self.info_saved.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_saved)
        self.info_saved.setChecked(True)

        self.info_generated = QCheckBox("Generated")
        self.info_generated.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_generated)
        self.info_generated.setChecked(False)

        self.info_compiled = QCheckBox("Compiled")
        self.info_compiled.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_compiled)
        self.info_compiled.setChecked(False)

        self.info_flashed = QCheckBox("Flashed")
        self.info_flashed.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_flashed)
        self.info_flashed.setChecked(False)

        info_layout.addStretch()

        self.button_save = QPushButton("Save")
        self.button_save.clicked.connect(self.save_config_cb)
        self.button_save.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save)

        self.button_save_as = QPushButton("Save as")
        self.button_save_as.clicked.connect(self.save_config_as)
        self.button_save_as.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save_as)

        self.button_generate = QPushButton("Generate")
        self.button_generate.clicked.connect(self.generate_cb)
        self.button_generate.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_generate)

        self.button_compile = QPushButton("Compile")
        self.button_compile.clicked.connect(self.compile_cb)
        self.button_compile.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_compile)

        self.button_flash = QPushButton("Flash")
        self.button_flash.clicked.connect(self.flash_cb)
        self.button_flash.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_flash)

        button = QPushButton("reload tree")
        button.clicked.connect(self.load_tree)
        button_layout.addWidget(button)

        button = QPushButton("reload config")
        button.clicked.connect(self.config_load)
        button_layout.addWidget(button)

        button = QPushButton("test-gui")
        button.clicked.connect(self.testgui)
        button_layout.addWidget(button)

        button = QPushButton("PyVCP-Preview")
        button.clicked.connect(self.open_pyvcp)
        button_layout.addWidget(button)

        self.addons = {}
        for addon_path in sorted(glob.glob(f"{riocore_path}/generator/addons/*/config.py")):
            addon_name = addon_path.split("/")[-2]
            self.addons[addon_name] = importlib.import_module(".config", f"riocore.generator.addons.{addon_name}")

        self.json_load()
        self.config_load()
        self.config_original = self.clean_config(self.config)
        self.config_checked = {}

        self.request_load_tree = 0
        self.request_load_hal = 0
        self.request_generate = 0
        self.request_pin_table_load = 0
        self.request_sig_table_load = 0
        self.timer = QTimer()
        self.timer.timeout.connect(self.runTimer)
        self.timer.start(1000)

    def select_board(self):
        def load_config_from():
            file_dialog = QFileDialog(self)
            suffix_list = ["*.json"]
            name = file_dialog.getOpenFileName(
                self,
                "Load Config",
                f"{riocore_path}/configs/",
                f"config ( {' '.join(suffix_list)} )" "Load Config",
                "",
            )
            if name[0]:
                dialog.close()
                self.config_file = name[0]

        def show_board_info(idx):
            board_path = board_list[idx]
            if board_path.endswith(".json"):
                board_name = board_path.split("/")[-1].replace(".json", "")
                board_raw = open(board_path, "r").read()
            else:
                board_name = board_path.split("/")[-1]
                board_raw = open(f"{board_path}/board.json", "r").read()
            board_config = json.loads(board_raw)

            pinimage = board_config.get("pinimage", "board.png")
            image_path = f"{board_path}/{pinimage}"
            if os.path.isfile(image_path):
                pixmap = QPixmap(image_path).scaled(320, 240, Qt.KeepAspectRatio)
                image_label.setPixmap(pixmap)
            else:
                image_label.clear()

            name_label.setText(board_name)
            description = []
            for key in ("name", "description", "type", "family", "toolchain"):
                value = board_config.get(key)
                description.append(f"{key.title()}: {value}")
            description_label.setText("\n".join(description))
            dialog.selected = board_name

        dialog = QDialog()
        dialog.setWindowTitle("create new config / select board")
        dialog.setStyleSheet(STYLESHEET)
        # dialog.setMinimumWidth(800)
        dialog.setMinimumHeight(480)

        dialog.layout = QVBoxLayout()
        dialog.setLayout(dialog.layout)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog_buttonBox.rejected.connect(dialog.reject)
        load_button = QPushButton(self.tr("Load existing config"))
        load_button.clicked.connect(load_config_from)
        dialog_buttonBox.addButton(load_button, QDialogButtonBox.ActionRole)

        board_table = QTableWidget()
        board_table.setColumnCount(1)
        board_table.setHorizontalHeaderItem(0, QTableWidgetItem("Boards"))
        header = board_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.Stretch)

        board_list = []
        board_n = 0
        for path in sorted(glob.glob(f"{riocore_path}/boards/*")):
            if path.endswith(".json"):
                board_name = path.split("/")[-1].replace(".json", "")
            else:
                if not os.path.isfile(f"{path}/board.json"):
                    print(f"WARNING: can not found board.json in {path}")
                    continue
                board_name = path.split("/")[-1]
            board_table.setRowCount(board_n + 1)
            board_list.append(path)
            pitem = QTableWidgetItem(board_name)
            board_table.setItem(board_n, 0, pitem)
            board_n += 1

        board_table.setFixedWidth(300)
        board_table.cellClicked.connect(show_board_info)
        board_table.currentCellChanged.connect(show_board_info)

        mid_layout = QVBoxLayout()
        mid_widget = QWidget()
        mid_widget.setFixedWidth(400)
        mid_widget.setLayout(mid_layout)
        name_label = QLabel("name")
        name_label_font = QFont()
        name_label_font.setBold(True)
        name_label.setFont(name_label_font)

        mid_layout.addWidget(name_label)
        description_label = QLabel("description")
        mid_layout.addWidget(description_label)
        mid_layout.addStretch()

        right_layout = QVBoxLayout()
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        image_label = QLabel(self)
        right_layout.addWidget(image_label)
        right_layout.addStretch()

        infos = QHBoxLayout()
        infos.addWidget(board_table, stretch=1)
        infos.addWidget(mid_widget, stretch=3)
        infos.addWidget(right_widget, stretch=1)

        dialog.layout.addLayout(infos)
        dialog.layout.addWidget(dialog_buttonBox)

        show_board_info(0)

        if dialog.exec():
            return dialog.selected

    def check_status(self):
        self.config_checked = self.clean_config(self.config)
        config_name = self.config.get("name")
        self.button_save.setEnabled(True)
        self.button_save_as.setEnabled(True)

        if self.config_original != self.clean_config(self.config):
            self.info_saved.setChecked(False)
            self.info_generated.setChecked(False)
            self.button_generate.setEnabled(False)
            self.button_compile.setEnabled(False)
            self.button_flash.setEnabled(False)
        else:
            self.info_saved.setChecked(True)
            self.button_generate.setEnabled(True)

            # checking generated config
            if os.path.isfile(f"Output/{config_name}/.config.json"):
                ret = os.system(f"diff {self.config_file} Output/{config_name}/.config.json >/dev/null")
            else:
                ret = 1
            if ret == 0:
                self.info_generated.setChecked(True)
                self.button_compile.setEnabled(True)
            else:
                self.info_generated.setChecked(False)
                self.button_compile.setEnabled(False)

        # checking gateware
        hash_compiled = ""

        if self.IS_FIRMWARE:
            hash_compiled_file = f"Output/{config_name}/Firmware/hash_compiled.txt"
            if os.path.isfile(hash_compiled_file):
                hash_compiled = open(hash_compiled_file, "r").read()
            if hash_compiled == self.firmware_hash:
                self.info_compiled.setChecked(True)
                self.button_flash.setEnabled(True)
            else:
                self.info_compiled.setChecked(False)
                self.button_flash.setEnabled(False)

            hash_flashed = ""
            hash_flashed_file = f"Output/{config_name}/Firmware/hash_flashed.txt"
            if os.path.isfile(hash_flashed_file):
                hash_flashed = open(hash_flashed_file, "r").read()
            if hash_flashed == self.firmware_hash:
                self.info_flashed.setChecked(True)
            else:
                self.info_flashed.setChecked(False)
        else:
            hash_compiled_file = f"Output/{config_name}/Gateware/hash_compiled.txt"
            if os.path.isfile(hash_compiled_file):
                hash_compiled = open(hash_compiled_file, "r").read()
            if hash_compiled == self.gateware_hash:
                self.info_compiled.setChecked(True)
                self.button_flash.setEnabled(True)
            else:
                self.info_compiled.setChecked(False)
                self.button_flash.setEnabled(False)

            hash_flashed = ""
            hash_flashed_file = f"Output/{config_name}/Gateware/hash_flashed.txt"
            if os.path.isfile(hash_flashed_file):
                hash_flashed = open(hash_flashed_file, "r").read()
            if hash_flashed == self.gateware_hash:
                self.info_flashed.setChecked(True)
            else:
                self.info_flashed.setChecked(False)

    def runTimer(self):
        if self.request_generate > 1:
            self.request_generate -= 1
        elif self.request_generate == 1:
            self.generate_cb(preview=True)
            self.request_generate = 0

        if self.pininfo_timer == 1:
            self.pininfo_timer = 0
            self.pininfo.setText("")
        elif self.pininfo_timer > 1:
            self.pininfo_timer -= 1

        if self.request_load_tree > 1:
            self.request_load_tree -= 1
        elif self.request_load_tree == 1:
            self.load_tree()
            self.request_load_tree = 0

        if self.request_load_hal > 1:
            self.request_load_hal -= 1
        elif self.request_load_hal == 1:
            self.load_hal()
            self.request_load_hal = 0

        if self.request_pin_table_load > 1:
            self.request_pin_table_load -= 1
        elif self.request_pin_table_load == 1:
            self.pin_table_load()
            self.request_pin_table_load = 0

        if self.request_sig_table_load > 1:
            self.request_sig_table_load -= 1
        elif self.request_sig_table_load == 1:
            self.sig_table_load()
            self.request_sig_table_load = 0

        if self.config_checked != self.clean_config(self.config):
            self.check_status()

        if self.compile_sub is not None:
            widget = self.gateware["Compile-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/compile.log", "r").read()
            widget.clear()
            duration = time.time() - self.compile_start

            if self.compile_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.compile_sub = None
                self.check_status()
                self.info_widget.setText(f"compile...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_compile.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"compile...({duration:0.1f}s)")

        if self.flash_sub is not None:
            widget = self.gateware["Flash-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/flash.log", "r").read()
            widget.clear()
            duration = time.time() - self.flash_start

            if self.flash_sub.poll() is not None:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.flash_sub = None
                self.check_status()
                self.info_widget.setText(f"flash...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                widget.verticalScrollBar().setValue(widget.verticalScrollBar().maximum())
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"flash...({duration:0.1f}s)")

    def onHeaderClickedPins(self, logicalIndex):
        logicalIndex += 1
        if self.pin_table_sort_col == logicalIndex:
            self.pin_table_sort_col = -logicalIndex
        else:
            self.pin_table_sort_col = logicalIndex
        self.pin_table_load()

    def onHeaderClickedSignals(self, logicalIndex):
        logicalIndex += 1
        if self.sig_table_sort_col == logicalIndex:
            self.sig_table_sort_col = -logicalIndex
        else:
            self.sig_table_sort_col = logicalIndex
        self.sig_table_load()

    def itemChanged(self, item):
        pass

    def json_load(self):
        # loading json config
        if self.config_file:
            configJsonStr = open(self.config_file, "r").read()
            if self.config_file.endswith(".yml"):
                self.config = yaml.load(configJsonStr)
            else:
                self.config = json.loads(configJsonStr)

        if "plugins" not in self.config:
            self.config["plugins"] = []

    def closeEvent(self, event):
        if self.config_original != self.clean_config(self.config):
            self.save_config_as()

    def setup_merge(self, setup, defaults):
        for key, value in defaults.items():
            if key not in setup:
                setup[key] = copy.deepcopy(value)
            elif isinstance(value, dict):
                self.setup_merge(setup[key], value)

    def get_path(self, path):
        if os.path.exists(path):
            return path
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        print(f"can not find path: {path}")
        exit(1)

    def get_boardpath(self, board):
        pathes = [
            f"{board}.json",
            f"{riocore_path}/boards/{board}.json",
            f"{riocore_path}/boards/{board}/board.json",
        ]
        for path in pathes:
            if os.path.exists(path):
                return path
        print(f"can not find board: {board}")
        exit(1)

    def testgui(self):
        print("starting testgui..", f"{os.path.dirname(__file__)}/rio-test")
        filename = f"{self.config_file}.test-gui-temp.json"
        self.save_config(filename)
        testgui_path = f"{os.path.dirname(__file__)}/rio-test"
        os.system(f"({testgui_path} {filename} ; rm {filename}) &")

    def add_plugin(self, pin_id, slot_name=None):
        plugin_needs = {}
        plugin_list = self.plugins.list()
        plugin_infos = {}
        for plugin in plugin_list:
            plugins = riocore.Plugins()
            plugins.load_plugins({"plugins": [{"type": plugin["name"]}]})
            plugin_needs[plugin["name"]] = {
                "inputs": 0,
                "outputs": 0,
                "inouts": 0,
                "opt_inputs": 0,
                "opt_outputs": 0,
                "opt_inouts": 0,
            }
            for pin_name, pin_defaults in plugins.plugin_instances[0].PINDEFAULTS.items():
                direction = pin_defaults["direction"]
                key = f"{direction}s"
                if pin_defaults.get("optional", False):
                    key = f"opt_{key}"
                plugin_needs[plugin["name"]][key] += 1
            plugin_infos[plugin["name"]] = {
                "description": plugins.plugin_instances[0].DESCRIPTION,
                "info": plugins.plugin_instances[0].INFO,
                "pins": plugins.plugin_instances[0].PINDEFAULTS,
                "signals": plugins.plugin_instances[0].SIGNALS,
            }

        possible_plugins = []
        if slot_name:
            # filter possible plugins if slot is set
            for slot in self.slots:
                if slot_name == slot["name"]:
                    compatible = slot.get("compatible")
                    if compatible:
                        possible_plugins = compatible
                    else:
                        default = slot.get("default")
                        if default:
                            possible_plugins.append(default)
                        slot_has = {
                            "inputs": 0,
                            "outputs": 0,
                            "inouts": 0,
                            "alls": 0,
                        }
                        for _pin_id, pin in slot["pins"].items():
                            if isinstance(pin, dict):
                                direction = pin.get("direction", "all")
                                slot_has[f"{direction}s"] += 1

                        for pname, plugin_data in plugin_needs.items():
                            match = True
                            for key in ("inputs", "outputs", "inouts"):
                                if not (slot_has[key] >= plugin_data[key] and slot_has[key] <= plugin_data[key] + plugin_data[f"opt_{key}"]):
                                    match = False
                            if match and pname and pname not in possible_plugins:
                                possible_plugins.append(pname)
                        for pname, plugin_data in plugin_needs.items():
                            match = True
                            for key in ("inputs", "outputs", "inouts"):
                                if slot_has[key] + slot_has["alls"] < plugin_data[key]:
                                    match = False
                            if match and pname and pname not in possible_plugins:
                                possible_plugins.append(pname)
                    break
        else:
            for pname, plugin_data in plugin_needs.items():
                possible_plugins.append(pname)

        dialog = QDialog()
        dialog.setWindowTitle("select plugin")
        dialog.setStyleSheet(STYLESHEET)

        dialog.layout = QVBoxLayout()
        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog.setLayout(dialog.layout)

        def show_plugin_info(idx):
            plugin_name = possible_plugins[idx]
            plugin_path = f"{riocore_path}/plugins/{plugin_name}"
            image_path = f"{plugin_path}/image.png"
            if os.path.isfile(image_path):
                pixmap = QPixmap(image_path)
                image_label.setPixmap(pixmap)
            else:
                image_label.clear()
            name_label.setText(plugin_name.replace("_", "-").title())
            info_label.setText(plugin_infos[plugin_name]["info"])
            description = plugin_infos[plugin_name]["description"] or "---"
            description += "\n\nPins:\n"
            for pin_name, pin_info in plugin_infos[plugin_name]["pins"].items():
                optional = pin_info.get("optional")
                if optional is True:
                    description += f"  {pin_name}: {pin_info['direction']} (optional)\n"
                else:
                    description += f"  {pin_name}: {pin_info['direction']}\n"
            description += "\nSignals:\n"
            for signal_name, signal_info in plugin_infos[plugin_name]["signals"].items():
                description += f"  {signal_name}: {signal_info['direction']}\n"

            description_label.setText(description)
            dialog.selected = plugin_name

        plugin_table = QTableWidget()
        plugin_table.setColumnCount(1)
        plugin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Plugins"))
        plugin_table.setRowCount(len(possible_plugins))
        for row, plugin_name in enumerate(possible_plugins):
            pitem = QTableWidgetItem(plugin_name)
            plugin_table.setItem(row, 0, pitem)
        plugin_table.setFixedWidth(200)
        plugin_table.cellClicked.connect(show_plugin_info)
        plugin_table.currentCellChanged.connect(show_plugin_info)

        mid_layout = QVBoxLayout()
        mid_widget = QWidget()
        mid_widget.setFixedWidth(400)
        mid_widget.setLayout(mid_layout)
        name_label = QLabel("name")
        name_label_font = QFont()
        name_label_font.setBold(True)
        name_label.setFont(name_label_font)

        mid_layout.addWidget(name_label)
        info_label = QLabel("info")
        mid_layout.addWidget(info_label)
        description_label = QLabel("description")
        mid_layout.addWidget(description_label)
        mid_layout.addStretch()

        right_layout = QVBoxLayout()
        right_widget = QWidget()
        right_widget.setLayout(right_layout)
        image_label = QLabel(self)
        right_layout.addWidget(image_label)
        right_layout.addStretch()

        infos = QHBoxLayout()
        infos.addWidget(plugin_table, stretch=1)
        infos.addWidget(mid_widget, stretch=3)
        infos.addWidget(right_widget, stretch=1)

        dialog.layout.addLayout(infos)
        dialog.layout.addWidget(dialog_buttonBox)

        show_plugin_info(0)

        if dialog.exec():
            plugin_id = len(self.config["plugins"])
            self.config["plugins"].append(
                {
                    "type": dialog.selected,
                    "pins": {},
                }
            )

            plugin_instance = self.plugins.load_plugin(plugin_id, self.config["plugins"][plugin_id], self.config)
            if plugin_instance:
                # auto select pins if slot is set
                if slot_name:
                    slotpins = {
                        "input": [],
                        "output": [],
                        "inout": [],
                        "all": [],
                    }
                    for spin_name, spin in slot.get("pins", {}).items():
                        direction = spin.get("direction", "all")
                        if self.get_plugin_by_pin(spin["pin"]) == (None, None):
                            if direction:
                                slotpins[direction].append(spin_name)

                    # map single pin plugin to pin_id
                    num_mandatory = 0
                    for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                        optional = pin_defaults.get("optional")
                        if optional is True:
                            continue
                        num_mandatory += 1

                    if num_mandatory == 1:
                        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                            optional = pin_defaults.get("optional")
                            if optional is True:
                                continue
                            direction = pin_defaults.get("direction", "all")
                            pinconfig = {"pin": f"{slot_name}:{pin_id}"}
                            if direction in slotpins and pin_id in slotpins[direction]:
                                slotpins[direction].remove(pin_id)
                            self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig
                    else:
                        # first mandatory pins
                        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                            optional = pin_defaults.get("optional")
                            if optional is True:
                                continue
                            direction = pin_defaults.get("direction", "all")
                            pinconfig = {"pin": ""}
                            # find matching pins by name
                            found = False
                            for spin in slotpins[direction]:
                                if pin_name.lower() == spin.lower():
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins[direction].remove(spin)
                                    found = True
                                    break
                            for spin in slotpins["all"]:
                                if pin_name.lower() == spin.lower():
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins["all"].remove(spin)
                                    found = True
                                    break
                            if not found:
                                # find matching pins by direction
                                for spin in slotpins[direction]:
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins[direction].remove(spin)
                                    found = True
                                    break
                                for spin in slotpins["all"]:
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins["all"].remove(spin)
                                    found = True
                                    break
                            self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig

                        # then optional pins
                        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                            optional = pin_defaults.get("optional", False)
                            if optional is False:
                                continue
                            direction = pin_defaults.get("direction", "all")
                            pinconfig = {"pin": None}
                            # find matching pins by name
                            found = False
                            for spin in slotpins[direction]:
                                if pin_name.lower() == spin.lower():
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins[direction].remove(spin)
                                    found = True
                                    break
                            if not found:
                                # find matching pins by direction
                                for spin in slotpins[direction]:
                                    pinconfig = {"pin": f"{slot_name}:{spin}"}
                                    slotpins[direction].remove(spin)
                                    found = True
                                    break
                            self.config["plugins"][plugin_id]["pins"][pin_name] = pinconfig

                self.tree_add_plugin(self.tree_plugins, plugin_instance, expand=True)
                self.display()

                self.edit_plugin(plugin_instance, plugin_instance.plugin_id, None, is_new=True)

            return dialog.selected

    def get_plugin_by_pin(self, pinsearch):
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin_str = pin_setup.get("pin", "")
                if pinsearch == pin_str:
                    return (plugin_instance, pin_name)

                pin_real = pin_str
                if pin_str in self.pinmapping:
                    pin_real = self.pinmapping[pin_str]
                if pinsearch == pin_real:
                    return (plugin_instance, pin_name)

        return (None, None)

    def pinlayout_mark(self, pkey):
        slot_name = pkey.split(":")[0]
        infotext = [f"Slot: {slot_name}"]
        infotext.append(f"Pins:")
        networks = []

        for key, label in self.pinlabels.items():
            splitted = key.split(":")
            if splitted[0] == slot_name:
                color = "darkCyan"
                label.mark(color)
                direction = label.pin.get("direction", "all")

                plugin_instance, pin_name = self.get_plugin_by_pin(label.pin["pin"])
                pinfo = ""
                if plugin_instance:
                    pinfo = f"-> {plugin_instance.title} ({plugin_instance.NAME}) : {pin_name}"

                    for signal_name, signal_config in plugin_instance.signals().items():
                        signal_direction = signal_config["direction"]
                        signal_halname = signal_config["halname"]
                        is_bool = signal_config.get("bool", False)
                        htype = "bit" if is_bool else "float"
                        if "userconfig" not in signal_config:
                            signal_config["userconfig"] = {}
                        userconfig = signal_config["userconfig"]
                        net = userconfig.get("net")
                        if net:
                            networks.append(net)

                if key == pkey:
                    pinfo += " <-"

                infotext.append(f" {splitted[1]}: {label.pin['pin']} ({direction}) {pinfo}")
            else:
                label.unmark()

        if len(infotext) > 2:
            if networks:
                infotext.append(f"Networks:")
                for net in networks:
                    infotext.append(f" {net}")
            self.pininfo.setText("\n".join(infotext))
            self.pininfo_timer = 0
        else:
            self.pininfo_timer = 3

    def get_module_by_slot(self, slot_name):
        if slot_name in self.modules:
            return self.modules[slot_name]["name"]
        return

    def remove_module(self, slot_name):
        module_name = self.get_module_by_slot(slot_name)
        qm = QMessageBox
        ret = qm.question(self, "remove module", f"Are you sure to remove module '{module_name}' from slot '{slot_name}' ?", qm.Yes | qm.No)
        if ret == qm.Yes:
            if "modules" in self.config:
                for mn, module in enumerate(self.config["modules"]):
                    if module["slot"] == slot_name:
                        self.config["modules"].pop(mn)
                        break
            del self.modules[slot_name]
            self.config_pinlayout()
            self.load_tree()
            self.pin_table_load()
            self.sig_table_load()
            self.display()

    def config_pinlayout(self):
        self.img_layout.removeWidget(self.boardimg)
        self.boardimg = QWidget()
        self.pinlabels = {}

        pinimage = self.board.get("pinimage")
        if not pinimage:
            if self.tabwidget.tabText(0) == "Board":
                self.tabwidget.removeTab(0)
            return

        pinlayout_pixmap = QPixmap(f"{self.boardcfg_path}/{pinimage}")
        self.boardimg.setFixedSize(pinlayout_pixmap.size())

        pinlayout_image = ImageMap(self)
        pinlayout_image.setAlignment(Qt.AlignRight | Qt.AlignTop)
        pinlayout_image.setFixedSize(pinlayout_pixmap.size())
        pinlayout_image.setPixmap(pinlayout_pixmap)

        self.img_layout.addWidget(self.boardimg)

        layout_box = QVBoxLayout(self.boardimg)
        layout_box.setContentsMargins(0, 0, 0, 0)
        layout_box.addWidget(pinlayout_image)

        for slot in self.slots:
            slot_name = slot["name"]
            module_name = self.get_module_by_slot(slot_name)

            if "rect" in slot:
                pkey = f"{slot_name}:"
                w = int(slot["rect"][2])
                h = int(slot["rect"][3])
                tooltip = f"slot:{slot_name}"
                bgcolor = "lightblue"
                if module_name:
                    bgcolor = "lightgreen"
                    tooltip += f"\nmodule: {module_name}"
                self.pinlabels[pkey] = PinButton(self.boardimg, parent=self, pkey=pkey, bgcolor=bgcolor, pin=pin)
                self.pinlabels[pkey].setFixedWidth(w)
                self.pinlabels[pkey].setFixedHeight(h)
                self.pinlabels[pkey].setText(pin_id)
                self.pinlabels[pkey].move(QPoint(int(slot["rect"][0]), int(slot["rect"][1])))
                self.pinlabels[pkey].setToolTip(tooltip)
                if module_name:
                    self.pinlabels[pkey].clicked.connect(partial(self.remove_module, slot_name))
                else:
                    self.pinlabels[pkey].clicked.connect(partial(self.select_module, set_slot=slot_name, slot_select=False))

            for pin_id, pin in slot["pins"].items():
                if isinstance(pin, dict):
                    # check if pin is allready used
                    pkey = f"{slot_name}:{pin_id}"

                    bgcolor = "blue"
                    if "pos" in pin:
                        tooltip = f"{slot_name}:{pin_id} {pin['pin']} ({pin.get('direction', 'all')})"
                    else:
                        tooltip = f"{slot_name}"

                    plugin_instance, pin_name = self.get_plugin_by_pin(pin["pin"])
                    if module_name:
                        bgcolor = "green"
                        tooltip += f"\nmodule: {module_name}"
                    elif plugin_instance:
                        bgcolor = "green"
                        tooltip += f"\n{plugin_instance.title} ({plugin_instance.NAME}) : {pin_name}"

                    if "pos" in pin:
                        self.pinlabels[pkey] = PinButton(self.boardimg, parent=self, pkey=pkey, bgcolor=bgcolor, pin=pin)
                        self.pinlabels[pkey].setFixedWidth(len(pin_id * 10))
                        self.pinlabels[pkey].setFixedHeight(15)
                        self.pinlabels[pkey].setText(pin_id)
                        self.pinlabels[pkey].move(QPoint(int(pin["pos"][0]), int(pin["pos"][1])))
                        self.pinlabels[pkey].setToolTip(tooltip)

                        if module_name:
                            self.pinlabels[pkey].clicked.connect(partial(self.remove_module, slot_name))
                        elif plugin_instance:
                            self.pinlabels[pkey].clicked.connect(partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id, None))
                        else:
                            self.pinlabels[pkey].clicked.connect(partial(self.add_plugin, pin_id, slot_name=slot_name))

                    elif "pos" in slot:
                        self.pinlabels[pkey] = PinButton(self.boardimg, parent=self, pkey=pkey, bgcolor=bgcolor, pin=pin)
                        self.pinlabels[pkey].setFixedWidth(len(slot_name * 10))
                        self.pinlabels[pkey].setFixedHeight(15)
                        self.pinlabels[pkey].setText(slot_name)
                        self.pinlabels[pkey].move(QPoint(int(slot["pos"][0]), int(slot["pos"][1])))
                        self.pinlabels[pkey].setToolTip(tooltip)

                        if module_name:
                            self.pinlabels[pkey].clicked.connect(partial(self.remove_module, slot_name))
                        elif plugin_instance:
                            self.pinlabels[pkey].clicked.connect(partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id, None))
                        else:
                            self.pinlabels[pkey].clicked.connect(partial(self.add_plugin, pin_id, slot_name=slot_name))

    def config_load(self):
        self.info_widget.setText(self.config_file)

        # loading board config
        boardcfg = self.config.get("boardcfg")
        self.boardcfg_path = None
        if boardcfg:
            board_file = self.get_boardpath(boardcfg)
            self.boardcfg_path = os.path.dirname(board_file)
            self.board = {}
            boardJsonStr = open(board_file, "r").read()
            self.board = json.loads(boardJsonStr)

        slot_pinmapping = {}
        self.slots = self.board.get("slots", []) + self.config.get("slots", [])
        for slot in self.slots:
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_name = f"{slot_name}:{pin_id}"
                slot_pinmapping[pin] = pin_name

        # loading slot/module configs
        self.modules = {}
        for module in self.config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup", {})
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            mplugins = riocore.Plugins()
            for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
                plugin_name = plugin_config.get("name")
                if plugin_name not in module_setup:
                    module_setup[plugin_name] = {}
                self.setup_merge(module_setup[plugin_name], plugin_config)
                if "pins" in module_setup[plugin_name]:
                    for pin in module_setup[plugin_name]["pins"]:
                        if "pin" in module_setup[plugin_name]["pins"][pin]:
                            module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                            del module_setup[plugin_name]["pins"][pin]["pin"]

                mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

            self.modules[slot_name] = {
                "name": module_name,
                "defaults": module_defaults,
                "setup": module_setup,
                "instances": mplugins.plugin_instances,
            }

        if self.board.get("toolchain") == "platformio":
            self.IS_FIRMWARE = True
            self.tabwidget.setTabVisible(5, False)
            self.tabwidget.setTabVisible(6, True)
        else:
            self.IS_FIRMWARE = False
            self.tabwidget.setTabVisible(5, True)
            self.tabwidget.setTabVisible(6, False)

        # loading plugins
        self.plugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)

        self.items = {}
        self.pinlist = []
        self.pinmapping = {}
        self.pinmapping_rev = {}
        self.expansion_pins = []
        for plugin_instance in self.plugins.plugin_instances:
            if plugin_instance.TYPE == "expansion":
                for pin in plugin_instance.expansion_outputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)
                for pin in plugin_instance.expansion_inputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                if "pins" not in plugin_instance.plugin_setup:
                    continue
                if pin_name not in plugin_instance.plugin_setup["pins"]:
                    plugin_instance.plugin_setup["pins"][pin_name] = {}
                pin_setup = plugin_instance.plugin_setup["pins"][pin_name]
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup.get("pin")
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
        for slot in self.slots:
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            for pin_name, pin in slot_pins.items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_id = f"{slot_name}:{pin_name}"
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
                self.pinmapping[pin_id] = pin
                self.pinmapping_rev[pin] = pin_id
                if pin_id not in self.pinlist:
                    self.pinlist.append(pin_id)

        def sort_key(value):
            if not value:
                return ""
            numbers = re.findall(r"\d+", value)
            for number in numbers:
                value = value.replace(number, f"{int(number):09d}")
            return value

        def load_pins(board):
            # try to load list of pins from chipdb files
            family = board.get("family")
            fpga_type = board.get("type")
            package = board.get("package")
            check_name = family.lower().replace(" ", "_")
            check_path = f"riocore/chipdata/{check_name}.json"
            if os.path.isfile(check_path):
                chipJsonStr = open(check_path, "r").read()
                chipData = json.loads(chipJsonStr)
                for fpga_id in [fpga_type, fpga_type.replace("up", "")]:
                    if fpga_id in chipData:
                        if package in chipData[fpga_id]:
                            for pin_name in chipData[fpga_id][package]:
                                if pin_name not in self.pinlist:
                                    self.pinlist.append(pin_name)
                        break

        load_pins(self.board)
        self.pinlist.sort(key=sort_key)

        boards_path = self.get_path("boards/")
        modules_path = self.get_path("modules/")

        self.interfaces = []
        for path in sorted(glob.glob(f"{riocore_path}/interfaces/*")):
            self.interfaces.append(path.split("/")[-1])
        self.boards = []
        for path in sorted(glob.glob(f"{boards_path}/*.json")):
            self.boards.append(path.split("/")[-1].split(".")[0])
        self.module_names = []
        for path in sorted(glob.glob(f"{modules_path}/*.json")):
            self.module_names.append(path.split("/")[-1].split(".")[0])
        self.slotnames = []
        for slot in self.slots:
            slot_name = slot.get("name")
            if slot_name:
                self.slotnames.append(slot_name)

        self.config_pinlayout()
        self.load_tree()
        self.pin_table_load()
        self.sig_table_load()
        self.display()

    def display(self):
        try:
            self.request_generate = 2
            self.request_pin_table_load = 2
            self.request_sig_table_load = 2
            self.overview_load()
            self.json_preview()
            self.info_widget.setText(self.config_file)
        except Exception as error:
            print(f"ERROR: {error}")
            self.info_widget.setText(f"ERROR: {error}")

    def open_pyvcp(self):
        try:
            if os.system("pidof linuxcncsvr") == 0:
                print(f"ERROR: linuxcnc is running")
                self.info_widget.setText(f"ERROR: linuxcnc is running")
            else:
                self.generate_cb(preview=True)
                if "rio-gui.xml" in self.linuxcnc:
                    xml_data = self.linuxcnc["rio-gui.xml"].toPlainText()
                    if xml_data:
                        tmp_file = ".tmp_rio-gui.xml"
                        os.system('ps fax | grep "pyvcp .tmp_rio-gui.xml" | grep -v grep | cut -d" " -f1 | xargs -r -l kill -4')
                        os.system("halcmd stop")
                        open(tmp_file, "w").write(xml_data)
                        os.system(f"(pyvcp '{tmp_file}' ; rm -f '{tmp_file}') &")
        except Exception as error:
            print(f"ERROR: {error}")
            self.info_widget.setText(f"ERROR: {error}")

    def struct_clean(self, data):
        # removing empty lists and dicts
        for key in list(data):
            if isinstance(data[key], list):
                for pn, part in enumerate(data[key]):
                    if isinstance(part, dict):
                        if not part:
                            print("DEL1", key, pn, data[key][pn])
                            del data[key][pn]
                        else:
                            self.struct_clean(data[key][pn])
                if not data[key]:
                    del data[key]
            elif isinstance(data[key], dict):
                self.struct_clean(data[key])
                if not data[key]:
                    del data[key]
            elif data[key] is None:
                del data[key]

    def clean_config(self, config_unclean):
        config = copy.deepcopy(config_unclean)
        # cleanup
        for module in config.get("modules", []):
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    if "pin_mapped" in pin_setup:
                        del pin_setup["pin_mapped"]
        for plugin in config.get("plugins", []):
            for name, plugin_config in plugin.get("config", {}).items():
                if "instance" in plugin_config:
                    del plugin_config["instance"]
        self.struct_clean(config)
        return config

    def json_preview(self):
        config = self.clean_config(self.config)
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText(json.dumps(config, indent=4))
        # self.jsonpreview.verticalScrollBar().setValue(0)

    def overview_load(self):
        num = 0
        fpga_name = f"{self.config.get('boardcfg')}"

        gAll = graphviz.Digraph("G", format="svg")
        gAll.attr(rankdir="LR")
        gAll.attr(bgcolor="black")

        lcports = []
        sports = []

        # show slots
        for slot in self.slots:
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            mportsl = []
            mportsr = []
            for pin_name, pin in slot_pins.items():
                if isinstance(pin, dict):
                    pin = pin["pin"]
                pin_id = f"{slot_name}_{pin_name}"
                mportsl.append(f"<{pin}>{pin}")
                mportsr.append(f"<{pin_id}>{pin_name}")

            label = f"{{ {{{' | '.join(mportsl)}}} | {slot_name} | {{{' | '.join(mportsr)}}} }}"
            sports.append(label)

        joint_n = 0
        for plugin_instance in self.plugins.plugin_instances:
            pports = []
            name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            if plugin_instance.TYPE == "expansion":
                title = plugin_instance.expansion_prefix

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                pports.append(f"<{pin_name}>{pin_name}")
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup.get("pin")
                if not pin:
                    continue

                con_dev = fpga_name
                con_pin = pin

                if pin and pin in self.expansion_pins:
                    con_dev = "_".join(pin.split("_")[0:-1])
                    con_pin = pin.replace("[", "").replace("]", "")

                if ":" in con_pin:
                    con_pin = con_pin.replace(":", "_")

                if pin_defaults["direction"] == "input":
                    modifiers = pin_setup.get("modifier", [])
                    color = "green"
                    arrow_dir = "forward"
                else:
                    modifiers = pin_setup.get("modifier", [])
                    if modifiers:
                        modifiers = reversed(modifiers)
                    color = "red"
                    arrow_dir = "back"

                if modifiers:
                    modifier_chain = []
                    for modifier_num, modifier in enumerate(modifiers):
                        modifier_type = modifier["type"]
                        modifier_chain.append(modifier_type)
                    modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                    gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                    con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                    con_pin = "r"
                    gAll.node(
                        f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                        shape="record",
                        label=modifier_label,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightyellow",
                    )

                gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)

                if pin and ":" not in pin and pin not in self.expansion_pins:
                    sports.append(f"<{pin}>{pin}")

                num += 1

            signalports = []
            for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                net = signal_config.get("net")
                function = signal_config.get("function")
                signalports.append(f"<signal_{signal_name}>{signal_name}")
                signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                direction_mapping = {"input": "normal", "output": "back", "inout": "both"}

                if not net and not function and plugin_instance.plugin_setup.get("is_joint", False):
                    if signal_name == "position" and signal_direction == "input":
                        hal_pin = f"joint.{joint_n}.motor-pos-fb"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="normal", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")
                    elif signal_name == "position" and signal_direction == "output":
                        hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")
                    elif signal_name == "velocity":
                        hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                        lcports.append(f"<{hal_pin}>{hal_pin}")

                if function:
                    gAll.edge(f"{title}:signal_{signal_name}", f"hal:{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    lcports.append(f"<{function}>{function}")
                if net:
                    gAll.edge(f"{title}:signal_{signal_name}", f"hal:{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    lcports.append(f"<{net}>{net}")

            if plugin_instance.TYPE == "expansion":
                eports = []
                for pname in plugin_instance.expansion_outputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")
                for pname in plugin_instance.expansion_inputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")

                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(eports)}}} }}"

            elif signalports:
                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
            else:
                label = f"{{ {{{' | '.join(pports)}}} | {title} }}"

            gAll.node(
                title,
                shape="record",
                label=label,
                fontsize="11pt",
                style="rounded, filled",
                fillcolor="lightblue",
            )

            if plugin_instance.plugin_setup.get("is_joint", False):
                joint_n += 1

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                pports = []
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if "pin_mapped" not in pin_setup:
                        continue

                    pin = f"{slot_name}_{pin_setup['pin_mapped']}"
                    con_dev = fpga_name
                    con_pin = pin

                    if pin and pin in self.expansion_pins:
                        con_dev = "_".join(pin.split("_")[0:-1])
                        con_pin = pin.replace("[", "").replace("]", "")

                    if pin_defaults["direction"] == "input":
                        modifiers = pin_setup.get("modifier", [])
                        color = "green"
                        arrow_dir = "forward"
                    else:
                        modifiers = pin_setup.get("modifier", [])
                        if modifiers:
                            modifiers = reversed(modifiers)
                        color = "red"
                        arrow_dir = "back"

                    if modifiers:
                        modifier_chain = []
                        for modifier_num, modifier in enumerate(modifiers):
                            modifier_type = modifier["type"]
                            modifier_chain.append(modifier_type)
                        modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                        gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                        con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                        con_pin = "r"
                        gAll.node(
                            f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                            shape="record",
                            label=modifier_label,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightyellow",
                        )

                    gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)
                    pports.append(f"<{pin_name}>{pin_name}")

                signalports = []
                for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                    net = signal_config.get("net")
                    function = signal_config.get("function")
                    signalports.append(f"<signal_{signal_name}>{signal_name}")
                    signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                    direction_mapping = {"input": "forward", "output": "back", "inout": "both"}

                    if not net and not function and plugin_instance.plugin_setup.get("is_joint", False):
                        if signal_name == "position" and signal_direction == "input":
                            hal_pin = f"joint.{joint_n}.motor-pos-fb"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="normal", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")
                        elif signal_name == "position" and signal_direction == "output":
                            hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")
                        elif signal_name == "velocity":
                            hal_pin = f"joint.{joint_n}.motor-pos-cmd"
                            gAll.edge(f"{title}:signal_{signal_name}", f"hal:{hal_pin}", dir="back", color="white", fontcolor="white")
                            lcports.append(f"<{hal_pin}>{hal_pin}")

                    if function:
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        lcports.append(f"<{function}>{function}")
                    if net:
                        gAll.edge(f"{title}:signal_{signal_name}", f"hal:{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        lcports.append(f"<{net}>{net}")

                if signalports:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
                else:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} }}"
                gAll.node(
                    title,
                    shape="record",
                    label=label,
                    fontsize="11pt",
                    style="rounded, filled",
                    fillcolor="lightblue",
                )

                if plugin_instance.plugin_setup.get("is_joint", False):
                    joint_n += 1

        label = f"{{ {{ {fpga_name}\\nPhysical-Pins | {' | '.join(sports)}}} }}"
        gAll.node(f"{fpga_name}", shape="record", label=label, fontsize="11pt", style="rounded, filled", fillcolor="yellow")

        label = f"{{ {{ LinuxCNC\\nHAL-Pins | {' | '.join(lcports)}}} }}"
        gAll.node(
            "hal",
            shape="record",
            label=label,
            fontsize="11pt",
            style="rounded, filled",
            fillcolor="lightgreen",
        )

        self.overview_img.load(gAll.pipe())
        self.overview_img.setFixedSize(self.overview_img.renderer().defaultSize())

    def sig_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def sig_table_load(self):
        self.sig_table.setRowCount(0)
        table_data = []

        def sort_key(a):
            col = a[idx]
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            for plugin_instance in self.modules[slot_name]["instances"]:
                for signal_name, signal_config in plugin_instance.signals().items():
                    signal_direction = signal_config["direction"]
                    signal_halname = signal_config["halname"]
                    is_bool = signal_config.get("bool", False)
                    htype = "bit" if is_bool else "float"

                    if "userconfig" not in signal_config:
                        signal_config["userconfig"] = {}
                    userconfig = signal_config["userconfig"]
                    signal_net = userconfig.get("net", "")
                    signal_function = userconfig.get("function", "")
                    signal_setp = str(userconfig.get("setp", ""))

                    key = "net"
                    if signal_function:
                        key = "function"
                    elif signal_setp:
                        key = "setp"

                    options_net = []
                    for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                        if is_bool:
                            if halpin_info.get("type") == bool:
                                options_net.append(halpin)
                        elif halpin_info.get("type") != bool:
                            options_net.append(halpin)

                    options_func = []
                    for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                        if is_bool:
                            if halpin_info.get("type") == bool:
                                options_func.append(halpin)
                        elif halpin_info.get("type") != bool:
                            options_func.append(halpin)

                    if key == "function":
                        widget = self.edit_item(userconfig, "function", {"type": "select", "options": options_func, "default": ""}, cb=self.sig_edit_cb)
                    elif key == "setp":
                        widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                    else:
                        widget = self.edit_item(userconfig, "net", {"type": "select", "options": options_net, "default": ""}, cb=self.sig_edit_cb)

                    table_data.append(
                        (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                    )

        for plugin_instance in self.plugins.plugin_instances:
            for signal_name, signal_config in plugin_instance.signals().items():
                signal_direction = signal_config["direction"]
                signal_halname = signal_config["halname"]
                is_bool = signal_config.get("bool", False)
                htype = "bit" if is_bool else "float"

                if "userconfig" not in signal_config:
                    signal_config["userconfig"] = {}
                userconfig = signal_config["userconfig"]
                signal_net = userconfig.get("net", "")
                signal_function = userconfig.get("function", "")
                signal_setp = str(userconfig.get("setp", ""))

                key = "net"
                if signal_function:
                    key = "function"
                elif signal_setp:
                    key = "setp"

                options_net = []
                for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_net.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_net.append(halpin)

                options_func = []
                for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options_func.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options_func.append(halpin)

                if key == "function":
                    widget = self.edit_item(userconfig, "function", {"type": "select", "options": options_func, "default": ""}, cb=self.sig_edit_cb)
                elif key == "setp":
                    widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                else:
                    widget = self.edit_item(userconfig, "net", {"type": "select", "options": options_net, "default": ""}, cb=self.sig_edit_cb)

                table_data.append(
                    (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                )

        if self.sig_table_sort_col > 0:
            idx = self.sig_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.sig_table_sort_col < 0:
            idx = -self.sig_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.sig_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row[:5]):
                pitem = QTableWidgetItem(col)
                self.sig_table.setItem(row_n, col_n, pitem)
            self.sig_table.setCellWidget(row_n, 2, row[7])

        # for col_n, col in enumerate(row[:5]):
        #    self.sig_table.resizeColumnToContents(col_n)

    def pin_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def pin_table_load(self):
        self.pin_table.setRowCount(0)
        in_use = set()
        table_data = []
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup.get("pin")
                if not pin:
                    continue
                pin_real = pin

                mapped = ""
                if pin in self.pinmapping_rev:
                    pin_real = self.pinmapping_rev[pin]
                    mapped = pin
                elif pin in self.pinmapping:
                    pin_real = self.pinmapping[pin]
                    mapped = pin

                comment = ""
                modifiers = pin_setup.get("modifier")
                if modifiers:
                    mlist = set()
                    for modifier in modifiers:
                        mlist.add(modifier["type"])
                    comment = f"{','.join(mlist)}"
                in_use.add(pin_real)
                table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"

                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if not pin_setup and pin_defaults.get("optional") is True:
                        continue
                    if "pin" not in pin_setup and pin_defaults.get("optional") is True:
                        continue

                    pin = pin_setup.get("pin", pin_setup.get("pin_mapped", "???"))
                    pin = f"{slot_name}:{pin}"
                    pin_real = pin

                    mapped = ""
                    if pin in self.pinmapping_rev:
                        pin_real = self.pinmapping_rev[pin]
                        mapped = pin
                    elif pin in self.pinmapping:
                        pin_real = self.pinmapping[pin]
                        mapped = pin

                    comment = ""
                    modifiers = pin_setup.get("modifier")
                    if modifiers:
                        mlist = set()
                        for modifier in modifiers:
                            mlist.add(modifier["type"])
                        comment = f"{','.join(mlist)}"
                    in_use.add(pin_real)
                    table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for pin in self.pinlist:
            if pin not in in_use:
                if pin in self.pinmapping:
                    continue
                if pin in self.pinmapping_rev:
                    if self.pinmapping_rev[pin] in in_use:
                        continue
                in_use.add(pin)
                table_data.append((pin, "", "", "", "", "unused"))

        def sort_key(a):
            col = a[idx]
            if not col:
                return ""
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        if self.pin_table_sort_col > 0:
            idx = self.pin_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.pin_table_sort_col < 0:
            idx = -self.pin_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.pin_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row):
                pitem = QTableWidgetItem(col)
                self.pin_table.setItem(row_n, col_n, pitem)
                self.pin_table.resizeColumnToContents(col_n)

    def edit_item(self, obj, key, var_setup=None, cb=None):
        if var_setup is None:
            var_setup = {}
        # if key not in obj and "default" in var_setup:
        #    obj[key] = var_setup["default"]

        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"), decimals=var_setup.get("decimals"))
        elif var_setup["type"] == bool:
            return edit_bool(self, obj, key, cb=cb, default=var_setup.get("default"))
        return edit_text(self, obj, key, cb=cb, default=var_setup.get("default"))

    def load_hal(self):
        print("loding hal overview")

    def load_tree(self):
        while self.model.rowCount() > 0:
            self.model.removeRow(0)

        for key, var_setup in {
            "name": {"type": str},
            "description": {"type": str},
            "boardcfg": {"type": "select", "options": self.boards},
            "protocol": {"type": "select", "options": self.interfaces, "default": "UDP"},
        }.items():
            aitem = MyStandardItem()
            self.model.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("LinuxCNC", help_text="LinuxCNC specific configurations"),
                bitem,
            ]
        )
        tree_lcnc = self.model.item(self.model.rowCount() - 1)
        if "linuxcnc" not in self.config:
            self.config["linuxcnc"] = {}

        for key, var_setup in {
            "num_axis": {"type": int, "min": 0, "max": 9, "default": 3},
            "machinetype": {"type": "select", "options": ["mill", "lathe", "corexy", "ldelta", "rdelta", "scara", "puma", "melfa"]},
            "toolchange": {"type": "select", "options": ["manual", "auto"], "default": "manual"},
            "gui": {"type": "select", "options": ["axis", "qtdragon", "tklinuxcnc", "touchy", "probe_basic"], "default": "axis"},
            "embed_vismach": {"type": "select", "options": ["", "fanuc_200f", "gantry_5axis", "millturn", "mill_xyz", "scara"], "default": ""},
        }.items():
            aitem = MyStandardItem()
            tree_lcnc.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config["linuxcnc"], key, var_setup))

        for addon_name, addon in self.addons.items():
            if hasattr(addon, "load_tree"):
                addon.load_tree(self, tree_lcnc)

        bitem = MyStandardItem()
        tree_lcnc.appendRow(
            [
                MyStandardItem("INI-Defaults", help_text="LinuxCNC INI-Defaults"),
                bitem,
            ]
        )
        tree_lcncini = tree_lcnc.child(tree_lcnc.rowCount() - 1)
        if "ini" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["ini"] = {}
        ini_config = self.config["linuxcnc"]["ini"]

        ini_data = riocore.generator.LinuxCNC.LinuxCNC.ini_defaults(self.config)
        for section, section_data in ini_data.items():
            if section not in ini_config:
                ini_config[section] = {}
            section_config = ini_config[section]

            aitem = MyStandardItem()
            tree_lcncini.appendRow(
                [
                    MyStandardItem(section),
                    MyStandardItem(""),
                ]
            )
            lcncsec_view = tree_lcncini.child(tree_lcncini.rowCount() - 1)
            for key, value in section_data.items():
                if value is not None and not isinstance(value, list):
                    var_setup = {"type": type(value), "default": value}
                    if section == "DISPLAY" and key == "POSITION_OFFSET":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RELATIVE", "MACHINE"]
                    if section == "DISPLAY" and key == "POSITION_FEEDBACK":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["COMMANDED", "ACTUAL"]
                    if section == "HAL" and key == "TWOPASS":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["ON", "OFF"]
                    if section == "DISPLAY" and key == "PYVCP_POSITION":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RIGHT", "BOTTOM"]

                    if section in help_text["INI"] and key in help_text["INI"][section]:
                        var_setup["tooltip"] = help_text["INI"][section][key]

                    key_title = key
                    if "|" in key:
                        key_title = f"{key.split('|')[0]} ({key.split('|')[1]})"
                    aitem = MyStandardItem()
                    lcncsec_view.appendRow(
                        [
                            MyStandardItem(key_title, help_text=var_setup.get("tooltip")),
                            aitem,
                        ]
                    )
                    self.treeview.setIndexWidget(aitem.index(), self.edit_item(section_config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Modules", help_text="Module-Configuration"),
                bitem,
            ]
        )
        tree_modules = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add module")
        button.clicked.connect(self.add_module)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(tree_modules))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"
            aitem = MyStandardItem()
            tree_modules.appendRow(
                [
                    MyStandardItem(title),
                    MyStandardItem(""),
                ]
            )
            module_view = tree_modules.child(tree_modules.rowCount() - 1)
            self.treeview.expand(self.model.indexFromItem(module_view))

            for key, var_setup in {
                "module": {"type": "select", "options": self.module_names},
                "slot": {"type": "select", "options": self.slotnames},
            }.items():
                aitem = MyStandardItem()
                module_view.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(module_data, key, var_setup, cb=self.slot_change))

            module_plugins_view = MyStandardItem("Plugins")
            module_view.appendRow(module_plugins_view)

            # self.treeview.expand(self.model.indexFromItem(module_plugins_view))

            for plugin_instance in self.modules[slot_name]["instances"]:
                self.tree_add_plugin(module_plugins_view, plugin_instance, nopins=True, expand=False)

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Plugins"),
                bitem,
            ]
        )
        self.tree_plugins = self.model.item(self.model.rowCount() - 1)

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button = QPushButton("add plugin")
        button.clicked.connect(self.add_plugin)
        button.setMaximumSize(button.sizeHint())
        buttons_layout.addWidget(button)

        buttons_layout.addStretch()
        self.treeview.setIndexWidget(bitem.index(), buttons_widget)
        self.treeview.expand(self.model.indexFromItem(self.tree_plugins))

        for plugin_instance in self.plugins.plugin_instances:
            self.tree_add_plugin(self.tree_plugins, plugin_instance)

        self.treeview.header().resizeSection(0, 300)
        self.treeview.header().resizeSection(1, 200)

    def slot_change(self, widget):
        self.config_load()

    def add_modifier(self, parent, pin_setup):
        if "modifier" not in pin_setup:
            pin_setup["modifier"] = []
        modifier_id = len(pin_setup.get("modifier", []))
        pin_setup["modifier"].append({"type": "invert"})
        modifier = pin_setup["modifier"][-1]
        self.tree_add_modifier(parent, pin_setup, modifier_id, modifier)
        self.display()

    def add_module(self, widget):
        last_error = None
        slot_name = None
        module_name = None
        while True:
            ret = self.select_module(last_error=last_error, set_slot=slot_name, set_module=module_name)
            if not ret:
                return
            slot_name, module_name = ret
            if not module_name or not slot_name:
                return

            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            slot_setup = {}
            for slot in self.slots:
                if slot_name == slot["name"]:
                    slot_setup = slot
            slot_pins = slot_setup.get("pins", {})

            check = True
            for plugin in module_defaults.get("plugins"):
                for pin_name, pin_config in plugin.get("pins", {}).items():
                    pin_location = pin_config.get("pin")
                    # print(pin_location, slot_pins)
                    if pin_location not in slot_pins:
                        check = False

            if check is True:
                break
            else:
                last_error = "ERROR: module/slot is not compatible"
                print(last_error)

        if "modules" not in self.config:
            self.config["modules"] = []

        module_setup = {}
        self.config["modules"].append(
            {
                "slot": slot_name,
                "module": module_name,
                "setup": module_setup,
            }
        )
        # print("module_instance", self.config["modules"])

        mplugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
            plugin_name = plugin_config.get("name")
            if plugin_name not in module_setup:
                module_setup[plugin_name] = {}
            self.setup_merge(module_setup[plugin_name], plugin_config)
            if "pins" in module_setup[plugin_name]:
                for pin in module_setup[plugin_name]["pins"]:
                    module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                    del module_setup[plugin_name]["pins"][pin]["pin"]

            mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

        self.modules[slot_name] = {
            "defaults": module_defaults,
            "setup": module_setup,
            "instances": mplugins.plugin_instances,
        }

        self.config_load()

    def del_plugin(self, plugin_instance, widget, dialog=None):
        plugin_id = plugin_instance.plugin_id
        if dialog is not None:
            dialog.is_removed = True
            dialog.close()
        self.config["plugins"].pop(plugin_id)
        self.config_load()
        self.display()

    def edit_modifier(self, modifier_list, modifier_id, parent_layout=None):
        def update():
            mods = []
            for modifier_id, modifier in enumerate(modifier_list):
                modifier_type = modifier.get("type", "???")
                if dialog.modifier_id == modifier_id:
                    mods.append(modifier_type.upper())
                else:
                    mods.append(modifier_type)
            dialog.mlabel.setText(f"Chain: {'>'.join(mods)}")

        def remove_modifier():
            modifier_list.pop(dialog.modifier_id)
            if parent_layout:
                self.modifier_list_update(parent_layout, modifier_list)
            dialog.close()

        def move_left():
            if dialog.modifier_id > 0:
                modifier_list[dialog.modifier_id - 1], modifier_list[dialog.modifier_id] = modifier_list[dialog.modifier_id], modifier_list[dialog.modifier_id - 1]
                if parent_layout:
                    self.modifier_list_update(parent_layout, modifier_list)
                dialog.modifier_id -= 1
                update()

        def move_right():
            if dialog.modifier_id < len(modifier_list) - 1:
                modifier_list[dialog.modifier_id + 1], modifier_list[dialog.modifier_id] = modifier_list[dialog.modifier_id], modifier_list[dialog.modifier_id + 1]
                if parent_layout:
                    self.modifier_list_update(parent_layout, modifier_list)
                dialog.modifier_id += 1
                update()

        dialog = QDialog()
        dialog.setWindowTitle("edit Modifier")
        dialog.setStyleSheet(STYLESHEET)
        dialog.modifier_id = modifier_id
        modifier_config = modifier_list[dialog.modifier_id]
        modifier_type = modifier_config.get("type", "???")

        dialog.layout = QVBoxLayout()
        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)

        remove_button = QPushButton(self.tr("Remove"))
        remove_button.clicked.connect(remove_modifier)
        dialog_buttonBox.addButton(remove_button, QDialogButtonBox.ActionRole)

        if len(modifier_list) > 1:
            move_button = QPushButton(self.tr("<<"))
            move_button.clicked.connect(move_left)
            dialog_buttonBox.addButton(move_button, QDialogButtonBox.ActionRole)

            move_button = QPushButton(self.tr(">>"))
            move_button.clicked.connect(move_right)
            dialog_buttonBox.addButton(move_button, QDialogButtonBox.ActionRole)

        dialog.layout.addWidget(QLabel(f"Type: {modifier_type}"))

        if modifier_type == "onerror":
            dialog.layout.addWidget(QLabel("Invert:"))
            dialog.layout.addWidget(self.edit_item(modifier_config, "invert", {"type": bool, "default": False}, cb=None))
        elif modifier_type == "debounce":
            dialog.layout.addWidget(QLabel("Delay:"))
            dialog.layout.addWidget(self.edit_item(modifier_config, "delay", {"type": int, "default": 16}, cb=None))
        elif modifier_type == "pwm":
            dialog.layout.addWidget(QLabel("Frequency:"))
            dialog.layout.addWidget(self.edit_item(modifier_config, "frequency", {"type": int, "default": 1}, cb=None))
            dialog.layout.addWidget(QLabel("DTY:"))
            dialog.layout.addWidget(self.edit_item(modifier_config, "dty", {"type": int, "default": 50}, cb=None))

        dialog.mlabel = QLabel("")
        dialog.layout.addWidget(dialog.mlabel)
        update()

        dialog.layout.addWidget(dialog_buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            modifier_list[dialog.modifier_id] = modifier_config

    def modifier_list_add(self, parent_layout, modifier_list):
        dialog = QDialog()
        dialog.setWindowTitle("add Modifier")
        dialog.setStyleSheet(STYLESHEET)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        label = QLabel("Modifier:")
        dialog.layout.addWidget(label)
        combo = QComboBox(self)
        for modifier_name in Modifiers().pin_modifier_list():
            combo.addItem(modifier_name)
        dialog.layout.addWidget(combo)

        dialog.layout.addWidget(dialog_buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            modifier_type = combo.currentText()
            modifier_list.append({"type": modifier_type})
            self.modifier_list_update(parent_layout, modifier_list)
            if modifier_type != "invert":
                self.edit_modifier(modifier_list, len(modifier_list) - 1, parent_layout)

    def modifier_list_update(self, parent_layout, modifier_list):
        pc = parent_layout.count()
        for i in reversed(range(pc)):
            parent_layout.itemAt(i).widget().setParent(None)

        for modifier_id, modifier in enumerate(modifier_list):
            modifier_type = modifier.get("type", "???")
            modifier_button = QPushButton(modifier_type)
            modifier_button.clicked.connect(partial(self.edit_modifier, modifier_list, modifier_id, parent_layout))
            modifier_button.setFixedWidth(len(modifier_type) * 9 + 10)
            parent_layout.addWidget(modifier_button, stretch=1)

    def edit_plugin_pins(self, plugin_instance, plugin_config):
        def update(arg):
            print("#update", arg, plugin_config)

        myFont = QFont()
        myFont.setBold(True)

        pins = QVBoxLayout()
        label = QLabel("Pin-Setup")
        label.setFont(myFont)
        pins.addWidget(label)

        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_config = plugin_config.get("pins", {}).get(pin_name, {})
            pin_title = pin_name
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional", False)
            help_text = f"location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"

            if optional:
                pin_title = f"{pin_title} (optional)"

            frame = QGroupBox(self)
            frame.setTitle(pin_title)
            frame.setToolTip(help_text)

            pin_rows = QVBoxLayout()

            pin_cols = QHBoxLayout()
            pin_rows.addLayout(pin_cols)
            pin_cols.addWidget(QLabel(f"Dir: {direction}"), stretch=1)

            # Options
            pin_cols = QHBoxLayout()
            pin_rows.addLayout(pin_cols)
            pin_cols.addWidget(QLabel("Pin:"), stretch=2)
            pin_cols.addWidget(self.edit_item(pin_config, "pin", {"type": "select", "options": self.pinlist, "default": ""}, cb=update), stretch=6)
            if direction == "input":
                pin_cols.addWidget(QLabel("Pull:"), stretch=1)
                pin_cols.addWidget(self.edit_item(pin_config, "pull", {"type": "select", "options": [None, "up", "down"], "default": None}, cb=update), stretch=3)
            else:
                pin_cols.addWidget(QLabel(""), stretch=4)

            # Modifiers
            if "modifier" not in pin_config:
                pin_config["modifier"] = []
            modifier_list = pin_config["modifier"]

            pin_cols = QHBoxLayout()
            pin_rows.addLayout(pin_cols)
            pin_cols.addWidget(QLabel("Modifiers:"))
            mod_cols = QHBoxLayout()
            pin_cols.addLayout(mod_cols)
            add_button = QPushButton("+")
            add_button.clicked.connect(partial(self.modifier_list_add, mod_cols, modifier_list))
            add_button.setFixedWidth(20)
            pin_cols.addWidget(add_button)
            pin_cols.addStretch()
            self.modifier_list_update(mod_cols, modifier_list)

            # IO-Standart
            pin_cols = QHBoxLayout()
            pin_rows.addLayout(pin_cols)

            io_label = QLabel("IO-Standart:")
            io_label.setToolTip("FPGA level IO config / optional / better do not use :)")
            pin_cols.addWidget(io_label, stretch=1)

            pin_cols.addWidget(
                self.edit_item(pin_config, "iostandard", {"type": "select", "options": ["LVTTL", "LVCMOS33", "LVCMOS25", "LVCMOS18", "LVCMOS15", "LVCMOS12"], "default": "LVTTL"}, cb=update), stretch=3
            )
            if direction == "output":
                pin_cols.addWidget(QLabel("Slew:"), stretch=1)
                pin_cols.addWidget(self.edit_item(pin_config, "slew", {"type": "select", "options": ["SLOW", "FAST"], "default": "SLOW"}, cb=update), stretch=3)
                pin_cols.addWidget(QLabel("Drive:"), stretch=1)
                pin_cols.addWidget(self.edit_item(pin_config, "drive", {"type": "select", "options": ["2", "4", "8", "12", "16", "24"], "default": "4"}, cb=update), stretch=3)
            else:
                pin_cols.addWidget(QLabel(""), stretch=8)

            frame.setLayout(pin_rows)
            pins.addWidget(frame)

        pins_widget = QWidget()
        pins.addStretch()
        pins_widget.setLayout(pins)

        pins_tab = QScrollArea()
        pins_tab.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        pins_tab.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        pins_tab.setWidgetResizable(True)
        pins_tab.setWidget(pins_widget)

        return pins_tab

    def draw_joint_home(self, joints_setup, joint_options):
        HOME_SEARCH_VEL = joints_setup.get("home_search_vel", joint_options["home_search_vel"].get("default", 0.0))
        HOME_LATCH_VEL = joints_setup.get("home_latch_vel", joint_options["home_latch_vel"].get("default", 0.0))
        HOME_FINAL_VEL = joints_setup.get("home_final_vel", joint_options["home_final_vel"].get("default", 0.0))
        HOME_OFFSET = joints_setup.get("home_offset", joint_options["home_offset"].get("default", 0.0))
        HOME = joints_setup.get("home", joint_options["home"].get("default", 0.0))
        HOME_SEQUENCE = joints_setup.get("home_sequence", joint_options["home_sequence"].get("default", 0.0))

        def svg_arrow_h(x, y, x2, color="rgb(255, 255, 255)"):
            svg_data = []
            if x < x2:
                svg_data.append(f'<line x1="{x}" y1="{y}" x2="{x2}" y2="{y}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2-10}" y2="{y-3}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2-10}" y2="{y+3}" stroke="{color}" stroke-width="1"></line>')
            else:
                svg_data.append(f'<line x1="{x}" y1="{y}" x2="{x2}" y2="{y}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2+10}" y2="{y-3}" stroke="{color}" stroke-width="1"></line>')
                svg_data.append(f'<line x1="{x2}" y1="{y}" x2="{x2+10}" y2="{y+3}" stroke="{color}" stroke-width="1"></line>')
            return svg_data

        def svg_line_h(x, y, w, color="rgb(255, 255, 255)"):
            return [f'<line x1="{x}" y1="{y}" x2="{x+w}" y2="{y}" stroke="{color}" stroke-width="1"></line>']

        def svg_line_v(x, y, h, color="rgb(255, 255, 255)"):
            return [f'<line x1="{x}" y1="{y}" x2="{x}" y2="{y+h}" stroke="{color}" stroke-width="1"></line>']

        def svg_text(x, y, text, center=False, color="rgb(255, 255, 255)"):
            if center:
                return [f'<text x="{x}" y="{y}" fill="{color}" text-anchor="middle">{text}</text>']
            else:
                return [f'<text x="{x}" y="{y}" fill="{color}">{text}</text>']

        y_diff = 15
        top = 12
        width = 400
        height = 6 * y_diff
        left = 95
        right = 10
        svg_data = [f'<svg width="{width}" height="{height}"><g><rect width="{width}" height="{height}" x="0" y="0" fill="black" />']

        min_pos = min(0, HOME, HOME_OFFSET) - 1.0
        max_pos = max(0, HOME, HOME_OFFSET) + 1.0

        scale_width = abs(max_pos - min_pos)
        scale = (width - left - right) / scale_width
        scale_offset = -min_pos * scale + left

        y_line = top + 3
        y_pos = top
        svg_data += svg_text(5, y_pos, "MACHINE")
        svg_data += svg_line_h(left, y_line, width - left - right)
        svg_data += svg_text(scale_offset, y_pos, "0.0", True)
        svg_data += svg_line_v(scale_offset, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "OFFSET")
        svg_data += svg_text(scale_offset + HOME_OFFSET * scale, y_pos, f"{HOME_OFFSET}", True)
        svg_data += svg_line_v(scale_offset + HOME_OFFSET * scale, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "HOME")
        svg_data += svg_text(scale_offset + HOME * scale, y_pos, f"{HOME}", True)
        svg_data += svg_line_v(scale_offset + HOME * scale, y_line - 2, 5)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "SEARCH_VEL")
        if HOME_SEARCH_VEL > 0:
            svg_data += svg_arrow_h(scale_offset + (max_pos - 0.2) * scale, y_pos - 3, scale_offset + HOME_OFFSET * scale)
        else:
            svg_data += svg_arrow_h(scale_offset + (min_pos + 0.2) * scale, y_pos - 3, scale_offset + HOME_OFFSET * scale)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "LATCH_VEL")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale - 2, y_pos - 3 - (y_diff / 2), scale_offset + HOME_OFFSET * scale + 22, color="rgb(200, 100, 100)")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale + 22, y_pos - 3, scale_offset + HOME_OFFSET * scale)

        y_pos += y_diff
        svg_data += svg_text(5, y_pos, "FINAL_VEL")
        svg_data += svg_arrow_h(scale_offset + HOME_OFFSET * scale, y_pos - 3, scale_offset + HOME * scale)

        svg_data.append(f"</g></svg>")
        return "\n".join(svg_data).encode()

    def edit_plugin_joints(self, plugin_instance, plugin_config):
        def update(arg):
            svgWidget.load(self.draw_joint_home(joints_setup, joint_options))

        myFont = QFont()
        myFont.setBold(True)

        if "joint" not in plugin_config:
            plugin_config["joint"] = {}
        joints_setup = plugin_config["joint"]

        joint_options = copy.deepcopy(JOINT_OPTIONS)

        for key, value in riocore.generator.LinuxCNC.LinuxCNC.JOINT_DEFAULTS.items():
            key = key.lower()
            if key == "scale_out":
                key = "scale"
            if key in joint_options:
                joint_options[key.lower()]["default"] = value

        joint_tabs = QTabWidget()

        general_layout = QVBoxLayout()
        label = QLabel("Joint-Setup")
        label.setFont(myFont)
        general_layout.addWidget(label)

        for option, option_setup in joint_options.items():
            if option.startswith("home"):
                continue
            tootltip = help_text["INI"]["JOINT_NUM"].get(option.upper(), f"{option} config")
            option_row = QHBoxLayout()
            option_label = QLabel(option)
            option_label.setToolTip(tootltip)
            option_row.addWidget(option_label, stretch=1)
            option_widget = self.edit_item(joints_setup, option, option_setup, cb=update)
            option_row.addWidget(option_widget, stretch=3)
            general_layout.addLayout(option_row)

        general_tab = QWidget()
        general_layout.addStretch()
        general_tab.setLayout(general_layout)
        joint_tabs.addTab(general_tab, "General")

        homing_layout = QVBoxLayout()
        label = QLabel("Joint-Homing")
        label.setFont(myFont)
        homing_layout.addWidget(label)

        home_values = {}

        for option, option_setup in joint_options.items():
            if not option.startswith("home"):
                continue

            tootltip = help_text["INI"]["JOINT_NUM"].get(option.upper(), f"{option} config")
            option_row = QHBoxLayout()
            option_label = QLabel(option)
            option_label.setToolTip(tootltip)
            option_row.addWidget(option_label, stretch=1)
            option_widget = self.edit_item(joints_setup, option, option_setup, cb=update)
            option_row.addWidget(option_widget, stretch=3)
            homing_layout.addLayout(option_row)

        svgWidget = QtSvg.QSvgWidget()
        update(None)
        homing_layout.addStretch()
        homing_layout.addWidget(svgWidget)

        homing_tab = QWidget()
        homing_tab.setLayout(homing_layout)
        joint_tabs.addTab(homing_tab, "Homing")

        return joint_tabs

    def edit_plugin_signals(self, plugin_instance, plugin_config):
        def update(arg):
            print("#update", arg, plugin_config)

        def toggleGroup(ctrl):
            state = ctrl.isChecked()
            if state:
                ctrl.setFixedHeight(ctrl.sizeHint().height())
            else:
                ctrl.setFixedHeight(30)

        myFont = QFont()
        myFont.setBold(True)

        signals = QVBoxLayout()
        label = QLabel("Signals-Setup")
        label.setFont(myFont)
        signals.addWidget(label)

        if "signals" not in plugin_config:
            plugin_config["signals"] = {}
        signals_setup = plugin_config["signals"]

        for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
            # signal_table.setRowCount(row_n + 1)
            if signal_name not in signals_setup:
                signals_setup[signal_name] = {}
            help_text = f"{signal_name} config"

            signal_setup = signal_defaults.get("setup", {})
            signal_direction = signal_defaults["direction"]
            signal_multiplexed = signal_defaults.get("multiplexed", False)
            is_bool = signal_defaults.get("bool", False)

            options_net = []
            for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_net.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_net.append(halpin)

            options_func = []
            for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_func.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_func.append(halpin)

            frame = QGroupBox(self)
            frame.setTitle(signal_name)
            frame.setToolTip(help_text)

            signal_cols = QHBoxLayout()
            signal_rows = QVBoxLayout()
            signal_rows.addLayout(signal_cols)
            frame.setLayout(signal_rows)
            signals.addWidget(frame)

            if is_bool:
                signal_cols.addWidget(QLabel(f"Type: BOOL"), stretch=1)
            else:
                signal_cols.addWidget(QLabel(f"Type: FLOAT"), stretch=1)

            signal_cols.addWidget(QLabel(f"Dir: {signal_direction}"), stretch=1)

            if signal_multiplexed:
                signal_cols.addWidget(QLabel(f"Multiplexed: YES"), stretch=1)
            else:
                signal_cols.addWidget(QLabel(f"Multiplexed: NO"), stretch=1)

            signal_cols = QHBoxLayout()
            signal_rows.addLayout(signal_cols)
            signal_cols.addWidget(QLabel("Net:"), stretch=1)
            signal_setup["net"] = {"type": "select", "options": options_net}
            signal_cols.addWidget(self.edit_item(signals_setup[signal_name], "net", signal_setup["net"], cb=update), stretch=5)

            signal_cols = QHBoxLayout()
            signal_rows.addLayout(signal_cols)
            signal_cols.addWidget(QLabel("Function:"), stretch=1)
            signal_setup["function"] = {"type": "select", "options": options_func}
            signal_cols.addWidget(self.edit_item(signals_setup[signal_name], "function", signal_setup["function"], cb=update), stretch=5)

            if signal_direction == "output":
                signal_cols.addWidget(QLabel("setp:"), stretch=1)
                signal_setup["setp"] = {"type": str, "default": ""}
                signal_cols.addWidget(self.edit_item(signals_setup[signal_name], "setp", signal_setup["setp"], cb=update), stretch=1)

            signal_cols = QHBoxLayout()
            signal_rows.addLayout(signal_cols)

            if "source" not in signal_defaults and not signal_defaults.get("bool"):
                signal_cols.addWidget(QLabel(f"Scale"), stretch=1)
                signal_setup["scale"] = {"type": float, "default": 1.0}
                signal_cols.addWidget(self.edit_item(signals_setup[signal_name], "scale", signal_setup["scale"], cb=update), stretch=4)

                signal_cols.addWidget(QLabel(f"Offset"), stretch=1)
                signal_setup["offset"] = {"type": float, "default": 0.0}
                signal_cols.addWidget(self.edit_item(signals_setup[signal_name], "offset", signal_setup["offset"], cb=update), stretch=5)

            display_frame = QGroupBox(self)
            display_frame.setTitle("Display")
            display_frame.setToolTip(help_text)
            display_frame.setCheckable(True)
            display_frame.setChecked(False)
            toggleGroup(display_frame)
            display_frame.toggled.connect(partial(toggleGroup, display_frame))
            display_rows = QVBoxLayout()
            display_frame.setLayout(display_rows)
            signal_rows.addWidget(display_frame)

            if "display" not in signals_setup[signal_name]:
                signals_setup[signal_name]["display"] = {}
            direction = signal_defaults["direction"]
            virtual = signal_defaults.get("virtual", False)
            if virtual:
                # swap direction vor virt signals in component
                if direction == "input":
                    direction = "output"
                else:
                    direction = "input"

            if direction == "input" or signals_setup[signal_name].get("net"):
                if signal_defaults.get("bool"):
                    type_options = ["none", "led", "rectled"]
                else:
                    type_options = ["none", "number", "bar", "meter"]
            else:
                if signal_defaults.get("bool"):
                    type_options = ["none", "checkbutton", "button"]
                else:
                    type_options = ["none", "scale", "spinbox", "dial", "jogwheel"]
            display_setup = {
                "title": {"type": str},
                "section": {"type": str},
                "type": {"type": "select", "options": type_options},
            }
            if not signal_defaults.get("bool", False):
                display_setup["min"] = {"type": float, "default": None}
                display_setup["max"] = {"type": float, "default": None}
            for option, option_setup in display_setup.items():
                display_cols = QHBoxLayout()
                display_rows.addLayout(display_cols)
                display_cols.addWidget(QLabel(option.title()), stretch=1)
                display_cols.addWidget(self.edit_item(signals_setup[signal_name]["display"], option, option_setup, cb=None), stretch=5)

        signals_widget = QWidget()
        signals.addStretch()
        signals_widget.setLayout(signals)

        signals_tab = QScrollArea()
        signals_tab.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        signals_tab.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        signals_tab.setWidgetResizable(True)
        signals_tab.setWidget(signals_widget)
        return signals_tab

    def edit_plugin_options(self, plugin_instance, plugin_config):
        def update(arg):
            plugin_instance.update_title()
            iname_label.setText(plugin_instance.title)

        myFont = QFont()
        myFont.setBold(True)

        options = QVBoxLayout()

        infotext = plugin_instance.INFO
        label = QLabel(f"{infotext}\n")
        label.setFont(myFont)
        options.addWidget(label)
        descriptiontext = plugin_instance.DESCRIPTION
        label = QLabel(f"{descriptiontext}\n")
        options.addWidget(label)

        iname_row = QHBoxLayout()
        iname_row.addWidget(QLabel("Instance-Name"), stretch=1)
        iname_label = QLabel(plugin_instance.title)
        iname_row.addWidget(iname_label, stretch=3)
        options.addLayout(iname_row)

        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            option_row = QHBoxLayout()
            options.addLayout(option_row)
            option_label = QLabel(title)
            option_label.setToolTip(help_text)
            option_row.addWidget(option_label, stretch=1)
            option_row.addWidget(self.edit_item(plugin_config, option_name, option_defaults, cb=update), stretch=3)

        if plugin_instance.PLUGIN_CONFIG:
            button_config = QPushButton("config")
            cb = partial(self.config_plugin, plugin_instance, plugin_instance.plugin_id)
            button_config.clicked.connect(cb)
            button_config.setMaximumSize(button_config.sizeHint())
            options.addWidget(button_config)

        options_widget = QWidget()
        options.addStretch()
        options_widget.setLayout(options)

        options_tab = QScrollArea()
        options_tab.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        options_tab.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        options_tab.setWidgetResizable(True)
        options_tab.setWidget(options_widget)
        return options_tab

    def edit_plugin(self, plugin_instance, plugin_id, widget, is_new=False):
        plugin_config = self.config["plugins"][plugin_id]
        plugin_config_backup = copy.deepcopy(plugin_config)

        dialog = QDialog()
        dialog.is_removed = False
        dialog.setWindowTitle(f"edit Plugin {plugin_instance.NAME}")
        dialog.setStyleSheet(STYLESHEET)
        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog_buttonBox.rejected.connect(dialog.reject)

        if self.config["linuxcnc"].get("gui", "axis") == "axis":
            pyvcp_button = QPushButton(self.tr("PyVCP-Preview"))
            pyvcp_button.clicked.connect(self.open_pyvcp)
            dialog_buttonBox.addButton(pyvcp_button, QDialogButtonBox.ActionRole)

        if not is_new:
            remove_button = QPushButton(self.tr("Remove"))
            remove_button.clicked.connect(partial(self.del_plugin, plugin_instance, dialog=dialog))
            dialog_buttonBox.addButton(remove_button, QDialogButtonBox.ActionRole)

        tab_widget = QTabWidget()

        options_tab = self.edit_plugin_options(plugin_instance, plugin_config)
        tab_widget.addTab(options_tab, "Plugin")

        pins_tab = self.edit_plugin_pins(plugin_instance, plugin_config)
        tab_widget.addTab(pins_tab, "Pins")
        if is_new:
            tab_widget.setCurrentWidget(pins_tab)

        if plugin_instance.TYPE == "joint" and plugin_config.get("is_joint", False):
            joint_tab = self.edit_plugin_joints(plugin_instance, plugin_config)
            tab_widget.addTab(joint_tab, "Joint")
        elif plugin_instance.TYPE != "interface":
            signals_tab = self.edit_plugin_signals(plugin_instance, plugin_config)
            tab_widget.addTab(signals_tab, "Signals")

        right_layout = QVBoxLayout()
        plugin_path = f"{riocore_path}/plugins/{plugin_instance.NAME}"
        image_path = f"{plugin_path}/image.png"
        if os.path.isfile(image_path):
            ilabel = QLabel(self)
            pixmap = QPixmap(image_path)
            ilabel.setPixmap(pixmap)
            right_layout.addWidget(ilabel)
            right_layout.addStretch()

        hlayout = QHBoxLayout()
        hlayout.addWidget(tab_widget)
        hlayout.addLayout(right_layout)

        dialog_layout = QVBoxLayout()
        dialog_layout.addLayout(hlayout)
        dialog_layout.addWidget(dialog_buttonBox)
        dialog.setLayout(dialog_layout)

        if dialog.exec():
            self.config_load()
            self.display()
            return
        if not dialog.is_removed:
            self.config["plugins"][plugin_id] = plugin_config_backup

    def config_plugin(self, plugin_instance, plugin_id, widget):
        if os.path.isfile(f"{riocore_path}/plugins/{plugin_instance.NAME}/config.py"):
            plugin_config = importlib.import_module(".config", f"riocore.plugins.{plugin_instance.NAME}")
            config_box = plugin_config.config(plugin_instance, styleSheet=STYLESHEET)
            config_box.run()
        self.config_load()
        self.load_tree()
        self.display()

    def plugin_config(self, plugin_instance=None):
        dialog = QDialog()
        dialog.setWindowTitle("Plugin-Config")
        dialog.setFixedWidth(800)
        dialog.setFixedHeight(600)
        dialog.setStyleSheet(STYLESHEET)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()

        hlayout = QHBoxLayout()

        vlayout_left = QVBoxLayout()

        if dialog.exec():
            return plugin_name.text()

    def select_module(self, last_error=None, set_slot=None, set_module=None, slot_select=True):
        dialog = QDialog()
        dialog.setWindowTitle("add Module")
        dialog.setStyleSheet(STYLESHEET)

        dialog_buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Ok)
        dialog_buttonBox.accepted.connect(dialog.accept)
        dialog_buttonBox.rejected.connect(dialog.reject)

        dialog.layout = QVBoxLayout()
        if last_error:
            message = QLabel(last_error)
            dialog.layout.addWidget(message)

        label = QLabel("Slot:")
        dialog.layout.addWidget(label)
        combo_slot = QComboBox(self)
        combo_slot.setDisabled(not slot_select)
        dialog.layout.addWidget(combo_slot)

        label = QLabel("Module:")
        dialog.layout.addWidget(label)
        combo_module = QComboBox(self)

        item = 0
        for slot in self.slots:
            slot_name = slot["name"]
            if slot_name not in self.modules:
                combo_slot.addItem(slot_name)
                if slot_name == set_slot:
                    combo_slot.setCurrentIndex(item)
                item += 1

        item = 0
        for module_name in self.module_names:
            combo_module.addItem(module_name)
            if module_name == set_module:
                combo_module.setCurrentIndex(item)
            item += 1

        dialog.layout.addWidget(combo_module)

        dialog.layout.addWidget(dialog_buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return (combo_slot.currentText(), combo_module.currentText())

    def flash_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Flash-Output"])

        widget = self.gateware["Flash-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.flash_start = time.time()
        self.flash_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make load 2>&1 | tee flash.log)", shell=True, close_fds=True)
        self.button_flash.setEnabled(False)
        self.info_widget.setText("flashing...")

    def compile_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Compile-Output"])

        widget = self.gateware["Compile-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.compile_start = time.time()
        self.compile_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make clean all 2>&1 | tee compile.log)", shell=True, close_fds=True)
        self.button_compile.setEnabled(False)
        self.info_widget.setText("compiling...")

    def generate_cb(self, preview=False):
        self.info_widget.setText("generate...")
        output_path = "Output"
        if preview:
            output_path = "OutputTMP"
        config_name = self.config.get("name")
        self.generate(output_path, preview=preview)
        try:
            if not self.IS_FIRMWARE:
                for filename, widget in self.gateware.items():
                    if not filename.endswith("-Output"):
                        file_content = open(f"{output_path}/{config_name}/Gateware/{filename}", "r").read()
                        widget.clear()
                        widget.insertPlainText(file_content)
                        if filename == "rio.v":
                            hash_md5 = hashlib.md5()
                            hash_md5.update(file_content.encode())
                            self.gateware_hash = hash_md5.hexdigest()
            else:
                for filename, widget in self.firmware.items():
                    if not filename.endswith("-Output"):
                        file_content = open(f"{output_path}/{config_name}/Firmware/{filename}", "r").read()
                        widget.clear()
                        widget.insertPlainText(file_content)
                        if filename == "src/main.ino":
                            hash_md5 = hashlib.md5()
                            hash_md5.update(file_content.encode())
                            self.firmware_hash = hash_md5.hexdigest()

            for filename, widget in self.linuxcnc.items():
                if filename == "rio-hal.svg":
                    if os.path.exists(f"{output_path}/{config_name}/LinuxCNC/rio.ini"):
                        os.system(f"python3 {riocore_path}/files/hal2graphviz.py -q -o {output_path}/{config_name}/LinuxCNC/{filename} {output_path}/{config_name}/LinuxCNC/rio.ini")
                    if os.path.exists(f"{output_path}/{config_name}/LinuxCNC/{filename}"):
                        self.hal_imagew.load(f"{output_path}/{config_name}/LinuxCNC/{filename}")
                        self.hal_imagew.setFixedSize(self.hal_imagew.renderer().defaultSize())
                else:
                    file_content = open(f"{output_path}/{config_name}/LinuxCNC/{filename}", "r").read()
                    widget.clear()
                    widget.insertPlainText(file_content)
        except Exception as error:
            print(f"ERROR loading output: {error}")
        if preview:
            os.system(f"rm -rf {output_path}/")
        self.info_widget.setText("generate...done")

    def generate(self, output_path=None, preview=False):
        config = self.clean_config(self.config)
        if not output_path:
            output_path = "Output"
        try:
            if preview:
                open(f"{self.config_file}_tmp.json", "w").write(json.dumps(config, indent=4))
                os.system(f"{riocore_path}/../bin/rio-generator -p {self.config_file}_tmp.json {output_path} >/dev/null")
                os.system(f"rm {self.config_file}_tmp.json")
            else:
                os.system(f"{riocore_path}/../bin/rio-generator {self.config_file} {output_path}")
                self.check_status()
        except Exception as error:
            print(f"ERROR generating output: {error}")

    def save_config_as(self, widget=None):
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilters(["json (*.json)"])

        if self.config_file:
            name = file_dialog.getSaveFileName(self, "Save File", self.config_file, "json (*.json)")
        else:
            name = file_dialog.getSaveFileName(self, "Save File", f"{riocore_path}/configs/", "json (*.json)")

        if name[0]:
            if not name[0].endswith(".json"):
                name[0] = f"{name[0]}.json"
            self.save_config(name[0])
            self.config_file = name[0]
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(name[0])}")
            self.check_status()

    def save_config_cb(self):
        self.save_config(self.config_file)
        if self.config_file is not None:
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(self.config_file)}")
            self.check_status()
        else:
            print("ERROR: saving config")
            self.info_widget.setText("ERROR: saving config")

    def save_config(self, filename):
        if filename is None:
            self.save_config_as()
        else:
            config = self.clean_config(self.config)
            open(filename, "w").write(json.dumps(config, indent=4))

    def tree_add_plugin(self, parent, plugin_instance, nopins=False, expand=False):
        name = plugin_instance.plugin_setup.get("name")
        title = plugin_instance.NAME
        if name:
            title = f"{name} ({plugin_instance.NAME})"

        help_text = plugin_instance.INFO

        aitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem(title, help_text=help_text),
                aitem,
            ]
        )

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        if not nopins:
            button_edit = QPushButton("edit")
            cb = partial(self.edit_plugin, plugin_instance, plugin_instance.plugin_id)
            button_edit.clicked.connect(cb)
            button_edit.setMaximumSize(button_edit.sizeHint())
            buttons_layout.addWidget(button_edit)

            button_delete = QPushButton("delete")
            cb = partial(self.del_plugin, plugin_instance)
            button_delete.clicked.connect(cb)
            button_delete.setMaximumSize(button_delete.sizeHint())
            buttons_layout.addWidget(button_delete)

        if plugin_instance.PLUGIN_CONFIG:
            button_config = QPushButton("config")
            cb = partial(self.config_plugin, plugin_instance, plugin_instance.plugin_id)
            button_config.clicked.connect(cb)
            button_config.setMaximumSize(button_config.sizeHint())
            buttons_layout.addWidget(button_config)
        buttons_layout.addStretch()
        self.treeview.setIndexWidget(aitem.index(), buttons_widget)

        plugin_view = parent.child(parent.rowCount() - 1)
        self.tree_add_options(plugin_view, plugin_instance, expand=expand)
        self.tree_add_pins(plugin_view, plugin_instance, expand=expand, nopins=nopins)
        if plugin_instance.TYPE == "joint" and plugin_instance.plugin_setup.get("is_joint", False):
            self.tree_add_joint(plugin_view, plugin_instance, expand=expand)
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        else:
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        if expand:
            self.treeview.expand(self.model.indexFromItem(plugin_view))

    def callback_plugin_name(self, parent, plugin_instance, value):
        parent.setText(f"{value} ({plugin_instance.NAME})")

    def tree_add_options(self, parent, plugin_instance, expand=False):
        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            aitem = MyStandardItem()
            parent.appendRow(
                [
                    MyStandardItem(title, help_text=help_text),
                    aitem,
                ]
            )
            cb = partial(self.callback_plugin_name, parent, plugin_instance)
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(plugin_instance.plugin_setup, option_name, option_defaults, cb=cb))

            options_view = parent.child(parent.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(options_view))

    def tree_add_modifier(self, parent, pin_setup, modifier_id, modifier):
        mitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem("Modifier"),
                mitem,
                MyStandardItem(""),
            ]
        )
        modifier_view = parent.child(parent.rowCount() - 1)
        self.treeview.setIndexWidget(mitem.index(), modifier_selector(self, pin_setup, modifier_id, modifier_view))

    def tree_add_signals(self, parent, plugin_instance, expand=False):
        signals_view = MyStandardItem("Signals", help_text="signal-configuration for this plugin instance")
        parent.appendRow(signals_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(signals_view))

        if "signals" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["signals"] = {}
        signals_setup = plugin_instance.plugin_setup["signals"]

        for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
            if signal_name not in signals_setup:
                signals_setup[signal_name] = {}
            help_text = f"{signal_name} config"

            signal_view = MyStandardItem(signal_name, help_text="signal-configuration for this plugin instance")
            signals_view.appendRow(signal_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(signal_view))

            signal_setup = signal_defaults.get("setup", {})
            signal_direction = signal_defaults["direction"]
            is_bool = signal_defaults.get("bool", False)

            options_net = []
            for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_net.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_net.append(halpin)

            options_func = []
            for halpin, halpin_info in halpins.RIO_FUNCTIONS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options_func.append(halpin)
                elif halpin_info.get("type") != bool:
                    options_func.append(halpin)

            signal_setup["net"] = {"type": "select", "options": options_net}
            signal_setup["function"] = {"type": "select", "options": options_func}

            if "source" not in signal_defaults and not signal_defaults.get("bool"):
                signal_setup["scale"] = {"type": float, "default": 1.0}
                signal_setup["offset"] = {"type": float, "default": 0.0}

            if signal_direction == "output":
                signal_setup["setp"] = {"type": str, "default": ""}

            for option, option_setup in signal_setup.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                signal_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = signal_view.child(signal_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

            display_view = MyStandardItem("Display", help_text="display-configuration for this signal")
            signal_view.appendRow(display_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(display_view))

            if signal_defaults["direction"] == "input" or signals_setup[signal_name].get("net"):
                if signal_defaults.get("bool"):
                    type_options = ["none", "led", "rectled"]
                else:
                    type_options = ["none", "number", "bar", "meter"]
            else:
                if signal_defaults.get("bool"):
                    type_options = ["none", "checkbutton", "button"]
                else:
                    type_options = ["none", "scale", "spinbox", "dial", "jogwheel"]

            if "display" not in signals_setup[signal_name]:
                signals_setup[signal_name]["display"] = {}

            display_setup = {
                "title": {"type": str},
                "section": {"type": str},
                "type": {"type": "select", "options": type_options},
                "min": {"type": float, "default": None},
                "max": {"type": float, "default": None},
            }

            for option, option_setup in display_setup.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                display_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = display_view.child(display_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name]["display"], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

    def tree_add_joint(self, parent, plugin_instance, expand=False):
        joint_view = MyStandardItem("Joint", help_text="joint-configuration for this plugin instance")
        parent.appendRow(joint_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(joint_view))

        if "joint" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["joint"] = {}
        joints_setup = plugin_instance.plugin_setup["joint"]

        joint_options = copy.deepcopy(JOINT_OPTIONS)

        for key, value in riocore.generator.LinuxCNC.LinuxCNC.JOINT_DEFAULTS.items():
            key = key.lower()
            if key == "scale_out":
                key = "scale"
            if key in joint_options:
                joint_options[key.lower()]["default"] = value

        for option, option_setup in joint_options.items():
            help_text = f"{option} config"
            citem = MyStandardItem()
            joint_view.appendRow(
                [
                    MyStandardItem(option, help_text=help_text),
                    citem,
                ]
            )
            joint_option_view = joint_view.child(joint_view.rowCount() - 1)
            # cb = partial(self.callback_plugin_name, parent, plugin_instance)
            cb = None
            self.treeview.setIndexWidget(citem.index(), self.edit_item(joints_setup, option, option_setup, cb=cb))
            if expand:
                self.treeview.expand(self.model.indexFromItem(joint_option_view))

    def tree_add_pins(self, parent, plugin_instance, expand=False, nopins=False):
        if not plugin_instance.PINDEFAULTS:
            return
        pins_view = MyStandardItem("Pins", help_text="pin-configuration for this plugin instance")
        parent.appendRow(pins_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(pins_view))
        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional")
            help_text = f"location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"

            pin_title = f"{pin_name} ({direction})"
            citem = MyStandardItem()
            pins_view.appendRow(
                [
                    MyStandardItem(pin_title, help_text=help_text),
                    citem,
                ]
            )
            if not nopins:
                self.treeview.setIndexWidget(citem.index(), self.edit_item(pin_setup, "pin", {"type": "select", "options": self.pinlist, "default": ""}))

            pin_view = pins_view.child(pins_view.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(pin_view))

            if direction == "input":
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("Pull", help_text="activate pullup/pulldown resistor for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "pull", {"type": "select", "options": [None, "up", "down"], "default": None}))
            else:
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("slew", help_text="set slew for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "slew", {"type": "select", "options": ["SLOW", "FAST"], "default": "SLOW"}))

                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("drive", help_text="set drive strength for this pin (not all values works on all FPGA's)"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "drive", {"type": "select", "options": ["2", "4", "8", "12", "16", "24"], "default": "4"}))
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("iostandard", help_text="set iostandard for this pin (not all values works on all FPGA's)"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(
                    pitem.index(), self.edit_item(pin_setup, "iostandard", {"type": "select", "options": ["LVTTL", "LVCMOS33", "LVCMOS25", "LVCMOS18", "LVCMOS15", "LVCMOS12"], "default": "LVTTL"})
                )

            bitem = MyStandardItem()
            pin_view.appendRow(
                [
                    MyStandardItem("Modifiers", help_text="pin modifier chain"),
                    bitem,
                ]
            )
            button = QPushButton("add")
            button.setMaximumSize(button.sizeHint())
            self.treeview.setIndexWidget(bitem.index(), button)
            modifiers_view = pin_view.child(pin_view.rowCount() - 1)
            button.clicked.connect(partial(self.add_modifier, modifiers_view, pin_setup))
            if expand:
                self.treeview.expand(self.model.indexFromItem(modifiers_view))

            for modifier_id, modifier in enumerate(pin_setup.get("modifier", [])):
                self.tree_add_modifier(modifiers_view, pin_setup, modifier_id, modifier)
            self.treeview.expand(self.model.indexFromItem(modifiers_view))


if __name__ == "__main__":
    app = QApplication(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config", nargs="?", type=str, default=None)
    parser.add_argument("--nostyle", "-n", help="disable stylesheets", default=False, action="store_true")
    args = parser.parse_args()

    if args.nostyle:
        STYLESHEET = ""

    form = WinForm(args)
    form.show()
    sys.exit(app.exec_())
